{"version":3,"file":"index.iife.min.js","sources":["../node_modules/deepmerge/dist/es.js","../src/utils/deepmerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/module/actions.js","../src/utils/debounceHelper.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/index.js","../src/module/errorCheck.js","../src/index.js"],"sourcesContent":["var isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tObject.keys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tObject.keys(source).forEach(function(key) {\n\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = deepmerge(target[key], source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nexport default deepmerge_1;\n","import deepmerge from 'deepmerge'\n// import deepmerge from '../../node_modules/deepmerge/dist/es.js'\n\n/**\n * Makes sure to overwrite arrays completely instead of concatenating with a merge(). Usage: merge(arr1, arr2, {arrayOverwrite: true})\n *\n * @returns the latter array passed\n */\nfunction overwriteMerge (destinationArray, sourceArray, options) {\n  return sourceArray\n}\n\nfunction merge (a, b, options) {\n  if (options && options.arrayOverwrite) {\n    return deepmerge(a, b, {arrayMerge: overwriteMerge})\n  }\n  return deepmerge(a, b)\n}\n\nmerge.all = function (array, options) {\n  if (options && options.arrayOverwrite) {\n    return deepmerge.all(array, {arrayMerge: overwriteMerge})\n  }\n  return deepmerge.all(array)\n}\n\nexport default merge\n","\n/**\n * A function executed during the 2 way sync when docs are added/modified/deleted. NEEDS TO EXECUTE FIRST PARAM! You can use this function to do a conditional check on the documents to decide if/when to execute the store update.\n *\n * @param {function} storeUpdateFn this is the function that will make changes to your vuex store. Takes no params.\n * @param {object} store the store for usage with `store.dispatch`, `store.commit`, `store.getters` etc.\n * @param {string} id the doc id returned in `change.doc.id` (see firestore documentation for more info)\n * @param {object} doc the doc returned in `change.doc.data()` (see firestore documentation for more info)\n * @param {string} source of the change. Can be 'local' or 'server'\n */\nfunction syncHook (storeUpdateFn, store, id, doc, source, change) {\n  // throw error if you want to stop the document in your store from being modified\n  // do some stuff\n  storeUpdateFn()\n  // do some stuff\n}\n\nexport default {\n  moduleNameSpace: 'firestore',\n  // this is the vuex module path that will be created\n  docsStateProp: '',\n  // this is the state property where your docs will end up inside the module\n  // when not set your doc's props will be set directly to your vuex module's state\n  firestorePath: '',\n  // this is the firestore collection path to your documents. You can use `{userId}` which will be replaced with `Firebase.auth().uid`\n  firestoreRefType: 'collection', // or 'doc'\n  // depending if what you want to sync is a whole collection or a single doc\n  vuexUserPath: '',\n  // the path where your firebase user gets saved in vuex. Required to be able to have reactivity after login.\n  sync: {\n    type: '2way',\n    // '2way' only ('read only' not yet integrated)\n    where: [], // only applicable on 'collection'\n    orderBy: [], // only applicable on 'collection'\n    defaultValues: {},\n    // About defaultValues:\n    // These are the default properties that will be set on each doc that's synced to the store or comes out of the store.\n    // You HAVE to set all props you want to be reactive on beforehand!\n    // These values are only set when you have items who don't have the props defined in defaultValues upon retrieval\n    // The retrieved document will be deep merged on top of these default values\n    added: syncHook,\n    modified: syncHook,\n    removed: syncHook,\n    // see the syncHook function above to see what you can do\n    // for firestoreRefType: 'doc' only use 'modified' syncHook\n  },\n  fetch: {\n    docLimit: 50, // defaults to 50\n  },\n  insert: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (doc, docs) { return (doc.something != 'something') },\n    fillables: [],\n    guard: [],\n  },\n  patch: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (id, fields, docs) { return (doc.something != 'something') },\n    fillables: [],\n    guard: [],\n  },\n  delete: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (id, docs) { return (doc.something != 'something') },\n  }\n}\n","\nexport default {\n  // user: null,\n  syncStack: {\n    updates: {},\n    deletions: [],\n    inserts: [],\n    debounceTimer: null\n  },\n  retrievedFetchRefs: [],\n  nextFetchRef: null,\n  patching: false,\n  doneFetching: false,\n  stopPatchingTimeout: null,\n}\n","import { defaultMutations } from 'vuex-easy-access'\nimport { isObject } from 'is-what'\nimport merge from '../utils/deepmerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$set(state[state.docsStateProp], doc.id, doc)\n  },\n  PATCH_DOC (state, doc) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') {\n      if (!state.docsStateProp) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined)\n            ? doc[key]\n            : (!isObject(state[key]) || !isObject(doc[key]))\n              ? doc[key]\n              : merge(state[key], doc[key], {arrayOverwrite: true})\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state.docsStateProp] will always be an empty object by default\n      state[state.docsStateProp] = merge(\n        state[state.docsStateProp],\n        doc,\n        {arrayOverwrite: true}\n      )\n      return\n    }\n    // Merge if exists\n    const newVal = (state[state.docsStateProp][doc.id] === undefined)\n      ? doc\n      : (!isObject(state[state.docsStateProp][doc.id]) || !isObject(doc))\n        ? doc\n        : merge(state[state.docsStateProp][doc.id], doc, {arrayOverwrite: true})\n    this._vm.$set(state[state.docsStateProp], doc.id, newVal)\n  },\n  DELETE_DOC (state, id) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$delete(state[state.docsStateProp], id)\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  const vuexEasyMutations = defaultMutations(state)\n  return Object.assign({}, vuexEasyMutations, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from './deepmerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj, {arrayOverwrite: true})\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport { isArray, isString } from 'is-what'\nimport merge from '../utils/deepmerge'\nimport copyObj from '../utils/copyObj'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], field = '', fields = []} = {ids: [], fields: []}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids) || !isArray(fields)) return console.log('ids, fields need to be arrays')\n    if (!isString(field)) return console.log('field needs to be a string')\n    if (id) ids.push(id)\n    if (field) fields.push(field)\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, fields)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(\n            state.syncStack.updates[id],\n            syncStackItems[id],\n            {arrayOverwrite: true}\n          )\n      state.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state.syncStack.deletions.concat(syncStackIds)\n    commit('SET_SYNCSTACK.DELETIONS', deletions)\n\n    if (!state.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state.syncStack.inserts.concat(syncStack)\n    commit('SET_SYNCSTACK.INSERTS', inserts)\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      commit('SET_SYNCSTACK.DEBOUNCETIMER', debounceTimer)\n    }\n    state.syncStack.debounceTimer.refresh()\n  },\n  batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = item.fields\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      commit('SET_SYNCSTACK.DELETIONS', deletionsLeft)\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      commit('SET_SYNCSTACK.INSERTS', insertsLeft)\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    commit('SET_SYNCSTACK.DEBOUNCETIMER', null)\n    return new Promise((resolve, reject) => {\n      batch.commit()\n      .then(res => {\n        console.log(`[batchSync] RESOLVED:`, res, `\n          updates: `, Object.keys(updates).length ? updates : {}, `\n          deletions: `, deletions.length ? deletions : [], `\n          inserts: `, inserts.length ? inserts : []\n        )\n        let remainingSyncStack = Object.keys(state.syncStack.updates).length\n          + state.syncStack.deletions.length\n          + state.syncStack.inserts.length\n        if (remainingSyncStack) { dispatch('batchSync') }\n        dispatch('_stopPatching')\n        return resolve()\n        // // Fetch the item if it was added as an Archived item:\n        // if (item.archived) {\n          //   get_ters.dbRef.doc(res.id).get()\n          //   .then(doc => {\n            //     let tempId = doc.data().id\n            //     let id = doc.id\n            //     let item = doc.data()\n            //     item.id = id\n            //     console.log('retrieved Archived new item: ', id, item)\n            //     dispatch('newItemFromServer', {item, tempId})\n            //   })\n            // }\n      }).catch(error => {\n        commit('SET_PATCHING', 'error')\n        commit('SET_SYNCSTACK.DEBOUNCETIMER', null)\n        return reject()\n      })\n    })\n  },\n  fetch (\n    {state, getters, commit},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      if (state.doneFetching) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fetchRef\n      if (state.nextFetchRef) {\n        // get next ref if saved in state\n        fetchRef = state.nextFetchRef\n      } else {\n        // apply where filters and orderBy\n        fetchRef = getters.dbRef\n        whereFilters.forEach(paramsArr => {\n          fetchRef = fetchRef.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          fetchRef = fetchRef.orderBy(...orderBy)\n        }\n      }\n      fetchRef = fetchRef.limit(state.fetch.docLimit)\n      // Stop if all records already fetched\n      if (state.retrievedFetchRefs.includes(fetchRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fetchRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          commit('SET_DONEFETCHING', true)\n          return resolve('fetchedAll')\n        }\n        if (docs.length < state.fetch.docLimit) {\n          commit('SET_DONEFETCHING', true)\n        }\n        commit('PUSH_RETRIEVEDFETCHREFS', fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fetchRef.startAfter(lastVisible)\n        commit('SET_NEXTFETCHREF', next)\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state.firestoreRefType.toLowerCase() !== 'doc') {\n      state.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn () {\n        return dispatch('serverUpdate', {change, id, doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state.sync[change]\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, this, id, doc, source)\n      } else {\n        storeUpdateFn()\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state.sync.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state.sync.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        commit('SET_PATCHING', 'error')\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (!doc.id || !state[state.docsStateProp][doc.id]) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({commit, dispatch, getters}, doc) {\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    commit('INSERT_DOC', doc)\n    return dispatch('insertDoc', doc)\n  },\n  patch ({commit, state, dispatch, getters}, doc) {\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    commit('PATCH_DOC', doc)\n    return dispatch('patchDoc', {id: doc.id, fields: Object.keys(doc)})\n  },\n  delete ({commit, dispatch, getters}, id) {\n    commit('DELETE_DOC', id)\n    return dispatch('deleteDoc', id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state.stopPatchingTimeout) { clearTimeout(state.stopPatchingTimeout) }\n    state.stopPatchingTimeout = setTimeout(_ => { commit('SET_PATCHING', false) }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state.stopPatchingTimeout) { clearTimeout(state.stopPatchingTimeout) }\n    commit('SET_PATCHING', true)\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    const user = getDeepRef(rootState, state.vuexUserPath)\n    return (user !== null)\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state.firestorePath.replace('{userId}', userId)\n    return (state.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state.docsStateProp)\n      ? `${state.moduleNameSpace}/${state.docsStateProp}`\n      : state.moduleNameSpace\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], fields = []) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      // Accept an extra condition to check\n      const check = state.patch.checkCondition\n      if (check && !check(id, fields, getters.storeRef)) return carry\n\n      let patchData = {}\n      // Patch specific fields only\n      if (fields.length) {\n        fields.forEach(field => {\n          patchData[field] = (collectionMode)\n            ? getters.storeRef[id][field]\n            : getters.storeRef[field]\n        })\n      // Patch the whole item\n      } else {\n        patchData = (collectionMode)\n          ? copyObj(getters.storeRef[id])\n          : copyObj(getters.storeRef)\n        patchData = checkFillables(patchData, state.patch.fillables, state.patch.guard)\n      }\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      // Accept an extra condition to check\n      let check = state.delete.checkCondition\n      if (check && !check(id, getters.storeRef)) return carry\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      // Accept an extra condition to check\n      let check = state.insert.checkCondition\n      if (check && !check(item, getters.storeRef)) return carry\n\n      item = checkFillables(item, state.insert.fillables, state.insert.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","import merge from '../utils/deepmerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\nconst vuexBase = {state: null, mutations: null, actions: null, getters: null}\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(vuexBase, userConfig, {arrayOverwrite: true})\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.docsStateProp) docContainer[conf.docsStateProp] = {}\n  const state = merge.all([initialState, defaultConfig, userState, conf, docContainer], {arrayOverwrite: true})\n\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'vuexUserPath']\n  reqProps.forEach(prop => {\n    console.error(`Missing ${prop} from your config!`)\n    return false\n  })\n  if (/(\\.|\\/)/.test(config.docsStateProp)) {\n    console.error(`docsStateProp must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleNameSpace)) {\n    console.error(`moduleNameSpace must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleNameSpace = getKeysFromPath(config.moduleNameSpace)\n      store.registerModule(moduleNameSpace, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["isMergeableObject","value","isNonNullObject","stringValue","Object","prototype","toString","call","$$typeof","REACT_ELEMENT_TYPE","isReactElement","isSpecial","Symbol","for","cloneUnlessOtherwiseSpecified","options","clone","deepmerge","val","Array","isArray","defaultArrayMerge","target","source","concat","map","element","arrayMerge","sourceIsArray","destination","keys","forEach","key","mergeObject","all","array","Error","reduce","prev","next","deepmerge_1","overwriteMerge","destinationArray","sourceArray","merge","a","b","arrayOverwrite","syncHook","storeUpdateFn","store","id","doc","change","mutations","state","syncStack","firestoreRefType","toLowerCase","_vm","$set","docsStateProp","newVal","undefined","isObject","$delete","copyObj","obj","newObj","JSON","parse","stringify","i","len","length","hasOwnProperty","defaultValues","actions","getters","dispatch","commit","ids","fields","field","console","log","isString","push","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","ms","startTime","signedIn","debounceTimer","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","then","collectionMode","dbRef","batch","Firebase","firestore","count","updatesOriginal","k","updatesOK","slice","updatesLeft","carry","item","docRef","update","deletionsAmount","deletionsOK","deletionsLeft","delete","insertsAmount","insertsOK","insertsLeft","newRef","set","res","catch","whereFilters","orderBy","doneFetching","fetchRef","nextFetchRef","where","paramsArr","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","lastVisible","startAfter","error","sync","handleDoc","type","syncHookFn","this","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","docChanges","stopPatchingTimeout","setTimeout","fillables","guard","rootState","rootGetters","getDeepRef","vuexUserPath","userId","auth","currentUser","uid","path","firestorePath","replace","collection","moduleNameSpace","check","patch","checkCondition","storeRef","patchData","checkFillables","updated_at","FieldValue","serverTimestamp","items","insert","created_at","created_by","vuexBase","userConfig","conf","config","prop","test","userState","userMutations","userActions","userGetters","docContainer","initialState","defaultConfig","vuexEasyMutations","defaultMutations","assign","iniMutations","iniActions","iniGetters","getKeysFromPath","registerModule","iniModule","setDoc","payload"],"mappings":"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"}