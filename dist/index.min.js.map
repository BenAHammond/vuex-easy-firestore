{"version":3,"file":"index.min.js","sources":["../node_modules/deepmerge/dist/es.js","../src/utils/overwriteMerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/module/actions.js","../src/utils/debounceHelper.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/index.js","../src/module/errorCheck.js","../src/index.js"],"sourcesContent":["var isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tObject.keys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tObject.keys(source).forEach(function(key) {\n\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = deepmerge(target[key], source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nexport default deepmerge_1;\n","\n/**\n * Makes sure to overwrite arrays completely instead of concatenating with a merge(). Usage: merge(arr1, arr2, {arrayMerge: overwriteMerge})\n *\n * @export\n * @returns the latter array passed\n */\nexport default function (destinationArray, sourceArray, options) {\n  return sourceArray\n}\n","\n/**\n * A function executed during the 2 way sync when docs are added/modified/deleted. NEEDS TO EXECUTE FIRST PARAM! You can use this function to do a conditional check on the documents to decide if/when to execute the store update.\n *\n * @param {function} storeUpdateFn this is the function that will make changes to your vuex store. Takes no params.\n * @param {object} store the store for usage with `store.dispatch`, `store.commit`, `store.getters` etc.\n * @param {string} id the doc id returned in `change.doc.id` (see firestore documentation for more info)\n * @param {object} doc the doc returned in `change.doc.data()` (see firestore documentation for more info)\n * @param {string} source of the change. Can be 'local' or 'server'\n */\nfunction syncHook (storeUpdateFn, store, id, doc, source, change) {\n  // throw error if you want to stop the document in your store from being modified\n  // do some stuff\n  storeUpdateFn()\n  // do some stuff\n}\n\nexport default {\n  moduleNameSpace: 'firestore',\n  // this is the vuex module path that will be created\n  docsStateProp: '',\n  // this is the state property where your docs will end up inside the module\n  // when not set your doc's props will be set directly to your vuex module's state\n  firestorePath: '',\n  // this is the firestore collection path to your documents. You can use `{userId}` which will be replaced with `Firebase.auth().uid`\n  firestoreRefType: 'collection', // or 'doc'\n  // depending if what you want to sync is a whole collection or a single doc\n  vuexUserPath: '',\n  // the path where your firebase user gets saved in vuex. Required to be able to have reactivity after login.\n  sync: {\n    type: '2way',\n    // '2way' only ('read only' not yet integrated)\n    where: [], // only applicable on 'collection'\n    orderBy: [], // only applicable on 'collection'\n    defaultValues: {},\n    // About defaultValues:\n    // These are the default properties that will be set on each doc that's synced to the store or comes out of the store.\n    // You HAVE to set all props you want to be reactive on beforehand!\n    // These values are only set when you have items who don't have the props defined in defaultValues upon retrieval\n    // The retrieved document will be deep merged on top of these default values\n    added: syncHook,\n    modified: syncHook,\n    removed: syncHook,\n    // see the syncHook function above to see what you can do\n    // for firestoreRefType: 'doc' only use 'modified' syncHook\n  },\n  fetch: {\n    docLimit: 50, // defaults to 50\n  },\n  insert: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (doc, docs) { return (doc.something != 'something') },\n    fillables: [],\n    guard: [],\n  },\n  patch: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (id, fields, docs) { return (doc.something != 'something') },\n    fillables: [],\n    guard: [],\n  },\n  delete: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (id, docs) { return (doc.something != 'something') },\n  }\n}\n","\nexport default {\n  // user: null,\n  syncStack: {\n    updates: {},\n    deletions: [],\n    inserts: [],\n    debounceTimer: null\n  },\n  retrievedFetchRefs: [],\n  nextFetchRef: null,\n  patching: false,\n  doneFetching: false,\n  stopPatchingTimeout: null,\n}\n","import { defaultMutations } from 'vuex-easy-access'\nimport { isObject } from 'is-what'\nimport merge from '../../node_modules/deepmerge/dist/es.js'\nimport overwriteMerge from '../utils/overwriteMerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$set(state[state.docsStateProp], doc.id, doc)\n  },\n  PATCH_DOC (state, doc) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') {\n      if (!state.docsStateProp) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined)\n            ? doc[key]\n            : (!isObject(state[key]) || !isObject(doc[key]))\n              ? doc[key]\n              : merge(state[key], doc[key], {arrayMerge: overwriteMerge})\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state.docsStateProp] will always be an empty object by default\n      state[state.docsStateProp] = merge(\n        state[state.docsStateProp],\n        doc,\n        {arrayMerge: overwriteMerge}\n      )\n      return\n    }\n    // Merge if exists\n    const newVal = (state[state.docsStateProp][doc.id] === undefined)\n      ? doc\n      : (!isObject(state[state.docsStateProp][doc.id]) || !isObject(doc))\n        ? doc\n        : merge(state[state.docsStateProp][doc.id], doc, {arrayMerge: overwriteMerge})\n    this._vm.$set(state[state.docsStateProp], doc.id, newVal)\n  },\n  DELETE_DOC (state, id) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$delete(state[state.docsStateProp], id)\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  const vuexEasyMutations = defaultMutations(state)\n  return Object.assign({}, vuexEasyMutations, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from '../../node_modules/deepmerge/dist/es.js'\nimport overwriteMerge from './overwriteMerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj, {arrayMerge: overwriteMerge})\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport { isArray, isString } from 'is-what'\nimport merge from '../../node_modules/deepmerge/dist/es.js'\nimport copyObj from '../utils/copyObj'\nimport overwriteMerge from '../utils/overwriteMerge'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], field = '', fields = []} = {ids: [], fields: []}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids) || !isArray(fields)) return console.log('ids, fields need to be arrays')\n    if (!isString(field)) return console.log('field needs to be a string')\n    if (id) ids.push(id)\n    if (field) fields.push(field)\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, fields)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(\n            state.syncStack.updates[id],\n            syncStackItems[id],\n            {arrayMerge: overwriteMerge}\n          )\n      state.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state.syncStack.deletions.concat(syncStackIds)\n    commit('SET_SYNCSTACK.DELETIONS', deletions)\n\n    if (!state.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state.syncStack.inserts.concat(syncStack)\n    commit('SET_SYNCSTACK.INSERTS', inserts)\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      commit('SET_SYNCSTACK.DEBOUNCETIMER', debounceTimer)\n    }\n    state.syncStack.debounceTimer.refresh()\n  },\n  async batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = item.fields\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      commit('SET_SYNCSTACK.DELETIONS', deletionsLeft)\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      commit('SET_SYNCSTACK.INSERTS', insertsLeft)\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    commit('SET_SYNCSTACK.DEBOUNCETIMER', null)\n    await batch.commit()\n    .then(res => {\n      console.log(`[batchSync] RESOLVED:`, res, `\n        updates: `, Object.keys(updates).length ? updates : {}, `\n        deletions: `, deletions.length ? deletions : [], `\n        inserts: `, inserts.length ? inserts : []\n      )\n      let remainingSyncStack = Object.keys(state.syncStack.updates).length\n        + state.syncStack.deletions.length\n        + state.syncStack.inserts.length\n      if (remainingSyncStack) { dispatch('batchSync') }\n      dispatch('_stopPatching')\n\n      // // Fetch the item if it was added as an Archived item:\n      // if (item.archived) {\n        //   get_ters.dbRef.doc(res.id).get()\n        //   .then(doc => {\n          //     let tempId = doc.data().id\n          //     let id = doc.id\n          //     let item = doc.data()\n          //     item.id = id\n          //     console.log('retrieved Archived new item: ', id, item)\n          //     dispatch('newItemFromServer', {item, tempId})\n          //   })\n          // }\n    }).catch(error => {\n      commit('SET_PATCHING', 'error')\n      commit('SET_SYNCSTACK.DEBOUNCETIMER', null)\n      throw error\n    })\n  },\n  fetch (\n    {state, getters, commit},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      if (state.doneFetching) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fetchRef\n      if (state.nextFetchRef) {\n        // get next ref if saved in state\n        fetchRef = state.nextFetchRef\n      } else {\n        // apply where filters and orderBy\n        fetchRef = getters.dbRef\n        whereFilters.forEach(paramsArr => {\n          fetchRef = fetchRef.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          fetchRef = fetchRef.orderBy(...orderBy)\n        }\n      }\n      fetchRef = fetchRef.limit(state.fetch.docLimit)\n      // Stop if all records already fetched\n      if (state.retrievedFetchRefs.includes(fetchRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fetchRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          commit('SET_DONEFETCHING', true)\n          return resolve('fetchedAll')\n        }\n        if (docs.length < state.fetch.docLimit) {\n          commit('SET_DONEFETCHING', true)\n        }\n        commit('PUSH_RETRIEVEDFETCHREFS', fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fetchRef.startAfter(lastVisible)\n        commit('SET_NEXTFETCHREF', next)\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state.firestoreRefType.toLowerCase() !== 'doc') {\n      state.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn () {\n        return dispatch('serverUpdate', {change, id, doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state.sync[change]\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, this, id, doc, source)\n      } else {\n        storeUpdateFn()\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state.sync.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state.sync.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        commit('SET_PATCHING', 'error')\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (!doc.id || !state[state.docsStateProp][doc.id]) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({commit, dispatch, getters}, doc) {\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    commit('INSERT_DOC', doc)\n    return dispatch('insertDoc', doc)\n  },\n  patch ({commit, state, dispatch, getters}, doc) {\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    commit('PATCH_DOC', doc)\n    return dispatch('patchDoc', {id: doc.id, fields: Object.keys(doc)})\n  },\n  delete ({commit, dispatch, getters}, id) {\n    commit('DELETE_DOC', id)\n    return dispatch('deleteDoc', id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state.stopPatchingTimeout) { clearTimeout(state.stopPatchingTimeout) }\n    state.stopPatchingTimeout = setTimeout(_ => { commit('SET_PATCHING', false) }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state.stopPatchingTimeout) { clearTimeout(state.stopPatchingTimeout) }\n    commit('SET_PATCHING', true)\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    const user = getDeepRef(rootState, state.vuexUserPath)\n    return (user !== null)\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state.firestorePath.replace('{userId}', userId)\n    return (state.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state.docsStateProp)\n      ? `${state.moduleNameSpace}/${state.docsStateProp}`\n      : state.moduleNameSpace\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], fields = []) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      // Accept an extra condition to check\n      const check = state.patch.checkCondition\n      if (check && !check(id, fields, getters.storeRef)) return carry\n\n      let patchData = {}\n      // Patch specific fields only\n      if (fields.length) {\n        fields.forEach(field => {\n          patchData[field] = (collectionMode)\n            ? getters.storeRef[id][field]\n            : getters.storeRef[field]\n        })\n      // Patch the whole item\n      } else {\n        patchData = (collectionMode)\n          ? copyObj(getters.storeRef[id])\n          : copyObj(getters.storeRef)\n        patchData = checkFillables(patchData, state.patch.fillables, state.patch.guard)\n      }\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      // Accept an extra condition to check\n      let check = state.delete.checkCondition\n      if (check && !check(id, getters.storeRef)) return carry\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      // Accept an extra condition to check\n      let check = state.insert.checkCondition\n      if (check && !check(item, getters.storeRef)) return carry\n\n      item = checkFillables(item, state.insert.fillables, state.insert.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","// import merge from 'deepmerge'\nimport merge from '../../node_modules/deepmerge/dist/es.js'\nimport overwriteMerge from '../utils/overwriteMerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\nconst vuexBase = {state: null, mutations: null, actions: null, getters: null}\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(vuexBase, userConfig, {arrayMerge: overwriteMerge})\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.docsStateProp) docContainer[conf.docsStateProp] = {}\n  const state = merge.all([initialState, defaultConfig, userState, conf, docContainer], {arrayMerge: overwriteMerge})\n\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'vuexUserPath']\n  reqProps.forEach(prop => {\n    console.error(`Missing ${prop} from your config!`)\n    return false\n  })\n  if (/(\\.|\\/)/.test(config.docsStateProp)) {\n    console.error(`docsStateProp must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleNameSpace)) {\n    console.error(`moduleNameSpace must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\nimport 'regenerator-runtime/runtime'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleNameSpace = getKeysFromPath(config.moduleNameSpace)\n      store.registerModule(moduleNameSpace, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["isMergeableObject","value","stringValue","Object","prototype","toString","call","$$typeof","REACT_ELEMENT_TYPE","Symbol","for","cloneUnlessOtherwiseSpecified","options","clone","deepmerge","val","Array","isArray","defaultArrayMerge","target","source","concat","map","element","arrayMerge","destination","sourceIsArray","keys","forEach","key","all","array","Error","reduce","prev","next","deepmerge_1","destinationArray","sourceArray","syncHook","storeUpdateFn","store","id","doc","change","mutations","state","syncStack","firestoreRefType","toLowerCase","_vm","$set","docsStateProp","merge","overwriteMerge","newVal","undefined","isObject","$delete","copyObj","obj","newObj","JSON","parse","stringify","i","len","length","hasOwnProperty","defaultValues","actions","getters","dispatch","commit","ids","fields","field","console","log","isString","push","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","ms","startTime","signedIn","debounceTimer","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","then","collectionMode","dbRef","Firebase","firestore","batch","updatesOriginal","k","slice","updatesLeft","carry","item","updatesOK","docRef","update","count","deletionsAmount","deletionsLeft","deletionsOK","delete","insertsAmount","insertsLeft","insertsOK","newRef","set","res","catch","error","whereFilters","orderBy","doneFetching","fetchRef","nextFetchRef","where","paramsArr","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","lastVisible","startAfter","sync","handleDoc","type","syncHookFn","this","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","docChanges","stopPatchingTimeout","setTimeout","fillables","guard","rootState","rootGetters","getDeepRef","vuexUserPath","userId","auth","currentUser","uid","path","firestorePath","replace","collection","moduleNameSpace","check","patch","checkCondition","storeRef","patchData","checkFillables","updated_at","FieldValue","serverTimestamp","items","insert","created_at","created_by","vuexBase","userConfig","conf","config","prop","test","userState","userMutations","userActions","userGetters","docContainer","initialState","defaultConfig","vuexEasyMutations","defaultMutations","assign","iniMutations","iniActions","iniGetters","getKeysFromPath","registerModule","iniModule","setDoc","payload"],"mappings":"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"}