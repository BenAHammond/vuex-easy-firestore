{"version":3,"file":"index.umd.min.js","sources":["../src/utils/nanomerge.js","../src/utils/deepmerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/utils/objectFlattenToPaths.js","../src/module/actions.js","../src/utils/debounceHelper.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/index.js","../src/module/errorCheck.js","../src/index.js"],"sourcesContent":["var nanoclone = require('nanoclone').default\n\nfunction toArray (object) {\n  var result = []\n\n  for (var i = 0; i < object.length; ++i) {\n    result.push(object[i])\n  }\n\n  return result\n}\n\nvar types = [\n  {\n    name: 'primitive',\n\n    is: function (el) {\n      var type = typeof el\n\n      return (type === 'number' || type === 'string' || type === 'boolean')\n    },\n\n    default: 'default',\n\n    merge: {\n      default: function (merger, a, b) {\n        return b\n      }\n    }\n  },\n\n  {\n    name: 'object',\n\n    is: function (el) {\n      return el !== null && (typeof el === 'object')\n    },\n\n    default: 'deep',\n\n    merge: {\n      deep: function (merger, a, b) {\n        var result = {}\n\n        var keys = {\n          a: Object.keys(a),\n          b: Object.keys(b)\n        }\n\n        keys.a.concat(keys.b).forEach(function (key) {\n          result[key] = merger(a[key], b[key])\n        })\n\n        return result\n      }\n    }\n  },\n\n  {\n    name: 'array',\n\n    is: function (el) {\n      return Array.isArray(el)\n    },\n\n    default: 'replace',\n\n    merge: {\n      merge: function (merger, a, b) {\n        var result = []\n\n        for (var i = 0; i < Math.max(a.length, b.length); ++i) {\n          result.push(merger(a[i], b[i]))\n        }\n\n        return result\n      },\n\n      replace: function (merger, a, b) {\n        return nanoclone(b)\n      },\n\n      concat: function (merger, a, b) {\n        return (([]).concat(a)).concat(b)\n      }\n    }\n  }\n]\n\nfunction merge (config) {\n  if (!config) {\n    config = {}\n  }\n\n  config = {\n    strategy: config.strategy || {}\n  }\n\n  function determineType (a, b) {\n    for (var i = types.length - 1; i >= 0; --i) {\n      var type = types[i]\n\n      if (type.is(a) && type.is(b)) {\n        return type\n      } else if (type.is(a) || type.is(b)) {\n        break\n      }\n    }\n\n    return null\n  }\n\n  function merger (a, b) {\n    if (b === void 0) {\n      return nanoclone(a)\n    }\n\n    var type = determineType(a, b)\n\n    if (!type) {\n      return nanoclone(b)\n    }\n\n    var strategy = config.strategy[type.name] || type.default\n\n    return type.merge[strategy](merger, a, b)\n  }\n\n  return function () {\n    var elements = toArray(arguments)\n\n    return elements.reduceRight(function (result, element) {\n      return merger(element, result)\n    })\n  }\n}\n\nfunction wrapper () {\n  var args = toArray(arguments)\n\n  // custom config\n  if (args.length === 1) {\n    return merge(args[0])\n  }\n\n  return merge().apply(null, args)\n}\n\nexport default wrapper\n// module.exports = wrapper\n","import { isObject } from 'is-what'\n// import deepmerge from 'nanomerge'\nimport deepmerge from './nanomerge'\n\nfunction merge (...params) {\n  let l = params.length\n  for (l; l > 0; l--) {\n    const item = params[l - 1]\n    if (!isObject(item)) {\n      console.error('trying to merge a non-object: ', item)\n      return item\n    }\n  }\n  return deepmerge(...params)\n}\n\nexport default merge\n","\nexport default {\n  firestorePath: '',\n    // The path to a collection or doc in firestore. You can use `{userId}` which will be replaced with the user Id.\n  firestoreRefType: '',\n    // `'collection'` or `'doc'`. Depending on your `firestorePath`.\n  moduleName: '',\n    // The module name. Can be nested, eg. `'user/items'`\n  statePropName: '',\n    // The name of the property where the docs or doc will be synced to. If left blank it will be synced on the state of the module. (Please see [Sync directly to module state](#sync-directly-to-module-state) for more info)\n\n  // Related to the 2-way sync:\n  sync: {\n    where: [],\n    orderBy: [],\n    fillables: [],\n    guard: [],\n    // HOOKS for local changes:\n    insertHook: function (updateStore, doc, store) { return updateStore(doc) },\n    patchHook: function (updateStore, doc, store) { return updateStore(doc) },\n    deleteHook: function (updateStore, id, store) { return updateStore(id) },\n  },\n\n  // When items on the server side are changed:\n  serverChange: {\n    defaultValues: {},\n    // HOOKS for changes on SERVER:\n    addedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    modifiedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    removedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n  },\n\n  // When items are fetched through `dispatch('module/fetch', filters)`.\n  fetch: {\n    // The max amount of documents to be fetched. Defaults to 50.\n    docLimit: 50,\n  },\n\n  // You can also add custom state/getters/mutations/actions. These will be added to your module.\n  state: {},\n  getters: {},\n  mutations: {},\n  actions: {},\n}\n","\nexport default {\n  _sync: {\n    signedIn: false,\n    patching: false,\n    syncStack: {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    },\n    fetched: [],\n    stopPatchingTimeout: null\n  }\n}\n","import { isObject } from 'is-what'\nimport merge from '../utils/deepmerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state._sync.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    if (state._conf.statePropName) {\n      this._vm.$set(state[state._conf.statePropName], doc.id, doc)\n    } else {\n      this._vm.$set(state, doc.id, doc)\n    }\n  },\n  PATCH_DOC (state, doc) {\n    // When patching in single 'doc' mode\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') {\n      // if no target prop is the state\n      if (!state._conf.statePropName) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined || !isObject(state[key]) || !isObject(doc[key]))\n            ? doc[key]\n            : merge(state[key], doc[key])\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state._conf.statePropName] will always be an empty object by default\n      state[state._conf.statePropName] = merge(state[state._conf.statePropName], doc)\n      return\n    }\n    // Patching in 'collection' mode\n    // get the doc ref\n    const docRef = (state._conf.statePropName)\n      ? state[state._conf.statePropName][doc.id]\n      : state[doc.id]\n    // Merge if exists\n    const newVal = (docRef === undefined || !isObject(docRef) || !isObject(doc))\n      ? doc\n      : merge(docRef, doc)\n    if (state._conf.statePropName) {\n      this._vm.$set(state[state._conf.statePropName], doc.id, newVal)\n    } else {\n      this._vm.$set(state, doc.id, newVal)\n    }\n  },\n  DELETE_DOC (state, id) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    if (state._conf.statePropName) {\n      this._vm.$delete(state[state._conf.statePropName], id)\n    } else {\n      this._vm.$delete(state, id)\n    }\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  return Object.assign({}, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from './deepmerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj)\n}\n","import { isObject } from 'is-what'\n\nfunction retrievePaths (object, path, result) {\n  if (!isObject(object) || !Object.keys(object).length) {\n    if (!path) return object\n    result[path] = object\n    return result\n  }\n  return Object.keys(object).reduce((carry, key) => {\n    const pathUntilNow = (path)\n      ? path + '.'\n      : ''\n    const newPath = pathUntilNow + key\n    const extra = retrievePaths(object[key], newPath, result)\n    return Object.assign(carry, extra)\n  }, {})\n}\n\nexport default function (object) {\n  const result = {}\n  return retrievePaths(object, null, result)\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport { isArray, isString } from 'is-what'\nimport merge from '../utils/deepmerge'\nimport copyObj from '../utils/copyObj'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\nimport flattenToPaths from '../utils/objectFlattenToPaths'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], doc} = {ids: [], doc: {}}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) return console.log('ids needs to be an array')\n    if (id) ids.push(id)\n    if (doc.id) delete doc.id\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, doc)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state._sync.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(state._sync.syncStack.updates[id],\n                syncStackItems[id])\n      state._sync.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state._sync.syncStack.deletions.concat(syncStackIds)\n    state._sync.syncStack.deletions = deletions\n\n    if (!state._sync.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state._sync.syncStack.inserts.concat(syncStack)\n    state._sync.syncStack.inserts = inserts\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state._sync.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      state._sync.syncStack.debounceTimer = debounceTimer\n    }\n    state._sync.syncStack.debounceTimer.refresh()\n  },\n  batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state._sync.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state._sync.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = flattenToPaths(item.fields)\n      console.log('fields → ', fields)\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state._sync.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.deletions = deletionsLeft\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state._sync.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.inserts = insertsLeft\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    state._sync.syncStack.debounceTimer = null\n    return new Promise((resolve, reject) => {\n      batch.commit()\n      .then(res => {\n        console.log(`[batchSync] RESOLVED:`, res, `\n          updates: `, Object.keys(updates).length ? updates : {}, `\n          deletions: `, deletions.length ? deletions : [], `\n          inserts: `, inserts.length ? inserts : []\n        )\n        let remainingSyncStack = Object.keys(state._sync.syncStack.updates).length\n          + state._sync.syncStack.deletions.length\n          + state._sync.syncStack.inserts.length\n        if (remainingSyncStack) { dispatch('batchSync') }\n        dispatch('_stopPatching')\n        return resolve()\n        // // Fetch the item if it was added as an Archived item:\n        // if (item.archived) {\n          //   get_ters.dbRef.doc(res.id).get()\n          //   .then(doc => {\n            //     let tempId = doc.data().id\n            //     let id = doc.id\n            //     let item = doc.data()\n            //     item.id = id\n            //     console.log('retrieved Archived new item: ', id, item)\n            //     dispatch('newItemFromServer', {item, tempId})\n            //   })\n            // }\n      }).catch(error => {\n        state._sync.patching = 'error'\n        state._sync.syncStack.debounceTimer = null\n        return reject()\n      })\n    })\n  },\n  fetch (\n    {state, getters, commit, dispatch},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      const identifier = JSON.stringify({whereFilters, orderBy})\n      const fetched = state._sync.fetched[identifier]\n      // We've never fetched this before:\n      if (!fetched) {\n        let ref = getters.dbRef\n        // apply where filters and orderBy\n        whereFilters.forEach(paramsArr => {\n          ref = ref.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          ref = ref.orderBy(...orderBy)\n        }\n        state._sync.fetched[identifier] = {\n          ref,\n          done: false,\n          retrievedFetchRefs: [],\n          nextFetchRef: null\n        }\n      }\n      const fRequest = state._sync.fetched[identifier]\n      // We're already done fetching everything:\n      if (fRequest.done) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fRef = state._sync.fetched[identifier].ref\n      if (fRequest.nextFetchRef) {\n        // get next ref if saved in state\n        fRef = state._sync.fetched[identifier].nextFetchRef\n      }\n      fRef = fRef.limit(state._conf.fetch.docLimit)\n      // Stop if all records already fetched\n      if (fRequest.retrievedFetchRefs.includes(fRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          state._sync.fetched[identifier].done = true\n          resolve('fetchedAll')\n\n          return\n        }\n        if (docs.length < state._conf.fetch.docLimit) {\n          state._sync.fetched[identifier].done = true\n        }\n        state._sync.fetched[identifier].retrievedFetchRefs.push(fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fRef.startAfter(lastVisible)\n        state._sync.fetched[identifier].nextFetchRef = next\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    const store = this\n    if (Firebase.auth().currentUser) state._sync.signedIn = true\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state._conf.firestoreRefType.toLowerCase() !== 'doc') {\n      state._conf.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state._conf.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state._conf.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn (_doc) {\n        return dispatch('serverUpdate', {change, id, doc: _doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state._conf.serverChange[change + 'Hook']\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, doc, id, store, source, change)\n      } else {\n        storeUpdateFn(doc)\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state._conf.serverChange.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state._conf.serverChange.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        state._sync.patching = 'error'\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (\n      !doc.id ||\n      (!state._conf.statePropName && !state[doc.id]) ||\n      (state._conf.statePropName && !state[state._conf.statePropName][doc.id])\n    ) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({state, getters, commit, dispatch}, doc) {\n    const store = this\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('INSERT_DOC', _doc)\n      return dispatch('insertDoc', _doc)\n    }\n    // check for hooks\n    if (state._conf.sync.insertHook) {\n      return state._conf.sync.insertHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  patch ({state, getters, commit, dispatch}, doc) {\n    const store = this\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {id: _doc.id, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.sync.patchHook) {\n      return state._conf.sync.patchHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  patchBatch (\n    {state, getters, commit, dispatch},\n    {doc, ids = []}\n  ) {\n    const store = this\n    if (!doc) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {ids, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.sync.patchHook) {\n      return state._conf.sync.patchHook(storeUpdateFn, doc, store)\n    }\n    return storeUpdateFn(doc)\n  },\n  delete ({state, getters, commit, dispatch}, id) {\n    const store = this\n    // define the store update\n    function storeUpdateFn (_id) {\n      commit('DELETE_DOC', _id)\n      return dispatch('deleteDoc', _id)\n    }\n    // check for hooks\n    if (state._conf.sync.deleteHook) {\n      return state._conf.sync.deleteHook(storeUpdateFn, id, store)\n    }\n    return storeUpdateFn(id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.stopPatchingTimeout = setTimeout(_ => { state._sync.patching = false }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.patching = true\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    return state._sync.signedIn\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    if (!Firebase.auth().currentUser) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state._conf.firestorePath.replace('{userId}', userId)\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state._conf.statePropName)\n      ? `${state._conf.moduleName}/${state._conf.statePropName}`\n      : state._conf.moduleName\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], doc = {}) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      let patchData = {}\n      // retrieve full object\n      if (!Object.keys(doc).length) {\n        patchData = (collectionMode)\n          ? getters.storeRef[id]\n          : getters.storeRef\n      } else {\n        patchData = doc\n      }\n      patchData = copyObj(patchData)\n      patchData = checkFillables(patchData, state._conf.sync.fillables, state._conf.sync.guard)\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      item = checkFillables(item, state._conf.sync.fillables, state._conf.sync.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","import merge from '../utils/deepmerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(defaultConfig, userConfig)\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.statePropName) docContainer[conf.statePropName] = {}\n  const state = merge(initialState, userState, docContainer, {_conf: conf})\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'moduleName']\n  reqProps.forEach(prop => {\n    if (!config[prop]) {\n      console.error(`Missing ${prop} from your config!`)\n      return false\n    }\n  })\n  if (/(\\.|\\/)/.test(config.statePropName)) {\n    console.error(`statePropName must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleName)) {\n    console.error(`moduleName must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleName = getKeysFromPath(config.moduleName)\n      store.registerModule(moduleName, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.patchBatch = (path, payload) => {\n      return store.dispatch(path + '/patchBatch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["nanoclone","require","default","toArray","object","result","i","length","push","types","el","type","merger","a","b","keys","Object","concat","forEach","key","Array","isArray","Math","max","merge","config","is","determineType","strategy","name","arguments","reduceRight","element","l","item","isObject","error","args","apply","updateStore","doc","store","id","source","change","mutations","state","_sync","syncStack","_conf","firestoreRefType","toLowerCase","statePropName","_vm","$set","newVal","undefined","docRef","$delete","copyObj","obj","newObj","prototype","toString","call","JSON","parse","stringify","len","hasOwnProperty","defaultValues","retrievePaths","path","reduce","carry","newPath","extra","assign","actions","getters","dispatch","commit","ids","console","log","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","ms","startTime","signedIn","debounceTimer","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","then","collectionMode","dbRef","batch","Firebase","firestore","count","updatesOriginal","map","k","fields","updatesOK","slice","updatesLeft","flattenToPaths","update","deletionsAmount","deletionsOK","deletionsLeft","delete","insertsAmount","insertsOK","insertsLeft","newRef","set","res","catch","patching","whereFilters","orderBy","identifier","fetched","ref","where","paramsArr","fRequest","fRef","nextFetchRef","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","fetchRef","lastVisible","next","startAfter","this","auth","currentUser","sync","handleDoc","storeUpdateFn","_doc","syncHookFn","serverChange","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","docChanges","insertHook","patchHook","_id","deleteHook","stopPatchingTimeout","setTimeout","fillables","guard","rootState","rootGetters","userId","uid","firestorePath","replace","collection","moduleName","getDeepRef","patchData","checkFillables","storeRef","updated_at","FieldValue","serverTimestamp","items","created_at","created_by","userConfig","conf","defaultConfig","prop","test","userState","userMutations","userActions","userGetters","docContainer","initialState","iniMutations","iniActions","iniGetters","getKeysFromPath","registerModule","iniModule","setDoc","payload","insert","patch","patchBatch"],"mappings":"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"}