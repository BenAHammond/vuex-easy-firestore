{"version":3,"file":"index.umd.min.js","sources":["../src/utils/nanomerge.js","../src/utils/deepmerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/utils/objectFlattenToPaths.js","../src/module/actions.js","../src/utils/debounceHelper.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/index.js","../src/module/errorCheck.js","../src/index.js"],"sourcesContent":["var nanoclone = require('nanoclone').default\n\nfunction toArray (object) {\n  var result = []\n\n  for (var i = 0; i < object.length; ++i) {\n    result.push(object[i])\n  }\n\n  return result\n}\n\nvar types = [\n  {\n    name: 'primitive',\n\n    is: function (el) {\n      var type = typeof el\n\n      return (type === 'number' || type === 'string' || type === 'boolean')\n    },\n\n    default: 'default',\n\n    merge: {\n      default: function (merger, a, b) {\n        return b\n      }\n    }\n  },\n\n  {\n    name: 'object',\n\n    is: function (el) {\n      return el !== null && (typeof el === 'object')\n    },\n\n    default: 'deep',\n\n    merge: {\n      deep: function (merger, a, b) {\n        var result = {}\n\n        var keys = {\n          a: Object.keys(a),\n          b: Object.keys(b)\n        }\n\n        keys.a.concat(keys.b).forEach(function (key) {\n          result[key] = merger(a[key], b[key])\n        })\n\n        return result\n      }\n    }\n  },\n\n  {\n    name: 'array',\n\n    is: function (el) {\n      return Array.isArray(el)\n    },\n\n    default: 'replace',\n\n    merge: {\n      merge: function (merger, a, b) {\n        var result = []\n\n        for (var i = 0; i < Math.max(a.length, b.length); ++i) {\n          result.push(merger(a[i], b[i]))\n        }\n\n        return result\n      },\n\n      replace: function (merger, a, b) {\n        return nanoclone(b)\n      },\n\n      concat: function (merger, a, b) {\n        return (([]).concat(a)).concat(b)\n      }\n    }\n  }\n]\n\nfunction merge (config) {\n  if (!config) {\n    config = {}\n  }\n\n  config = {\n    strategy: config.strategy || {}\n  }\n\n  function determineType (a, b) {\n    for (var i = types.length - 1; i >= 0; --i) {\n      var type = types[i]\n\n      if (type.is(a) && type.is(b)) {\n        return type\n      } else if (type.is(a) || type.is(b)) {\n        break\n      }\n    }\n\n    return null\n  }\n\n  function merger (a, b) {\n    if (b === void 0) {\n      return nanoclone(a)\n    }\n\n    var type = determineType(a, b)\n\n    if (!type) {\n      return nanoclone(b)\n    }\n\n    var strategy = config.strategy[type.name] || type.default\n\n    return type.merge[strategy](merger, a, b)\n  }\n\n  return function () {\n    var elements = toArray(arguments)\n\n    return elements.reduceRight(function (result, element) {\n      return merger(element, result)\n    })\n  }\n}\n\nfunction wrapper () {\n  var args = toArray(arguments)\n\n  // custom config\n  if (args.length === 1) {\n    return merge(args[0])\n  }\n\n  return merge().apply(null, args)\n}\n\nexport default wrapper\n// module.exports = wrapper\n","import { isObject } from 'is-what'\nimport deepmerge from './nanomerge'\n\nfunction merge (...params) {\n  let l = params.length\n  for (l; l > 0; l--) {\n    const item = params[l - 1]\n    if (!isObject(item)) {\n      console.error('trying to merge a non-object: ', item)\n      return item\n    }\n  }\n  return deepmerge(...params)\n}\n\nexport default merge\n","\nexport default {\n  firestorePath: '',\n    // The path to a collection or doc in firestore. You can use `{userId}` which will be replaced with the user Id.\n  firestoreRefType: '',\n    // `'collection'` or `'doc'`. Depending on your `firestorePath`.\n  moduleName: '',\n    // The module name. Can be nested, eg. `'user/items'`\n  statePropName: '',\n    // The name of the property where the docs or doc will be synced to. If left blank it will be synced on the state of the module. (Please see [Sync directly to module state](#sync-directly-to-module-state) for more info)\n\n  // Related to the 2-way sync:\n  sync: {\n    where: [],\n    orderBy: [],\n    fillables: [],\n    guard: [],\n  },\n\n  // HOOKS:\n  insertHook: function (updateStore, doc, store) { return updateStore(doc) },\n  patchHook: function (updateStore, doc, store) { return updateStore(doc) },\n  deleteHook: function (updateStore, id, store) { return updateStore(id) },\n\n  // When items on the server side are changed:\n  serverChange: {\n    defaultValues: {},\n    // HOOKS for changes on SERVER:\n    addedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    modifiedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    removedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n  },\n\n  // When items are fetched through `dispatch('module/fetch', filters)`.\n  fetch: {\n    // The max amount of documents to be fetched. Defaults to 50.\n    docLimit: 50,\n  },\n\n  // You can also add custom state/getters/mutations/actions. These will be added to your module.\n  state: {},\n  getters: {},\n  mutations: {},\n  actions: {},\n}\n","\nexport default {\n  _sync: {\n    signedIn: false,\n    patching: false,\n    syncStack: {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    },\n    fetched: [],\n    stopPatchingTimeout: null\n  }\n}\n","import { defaultMutations } from 'vuex-easy-access'\nimport { isObject } from 'is-what'\nimport merge from '../utils/deepmerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state._sync.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$set(state[state._conf.statePropName], doc.id, doc)\n  },\n  PATCH_DOC (state, doc) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') {\n      if (!state._conf.statePropName) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined)\n            ? doc[key]\n            : (!isObject(state[key]) || !isObject(doc[key]))\n              ? doc[key]\n              : merge(state[key], doc[key])\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state._conf.statePropName] will always be an empty object by default\n      state[state._conf.statePropName] = merge(state[state._conf.statePropName], doc)\n      return\n    }\n    // Merge if exists\n    const newVal = (state[state._conf.statePropName][doc.id] === undefined)\n      ? doc\n      : (!isObject(state[state._conf.statePropName][doc.id]) || !isObject(doc))\n        ? doc\n        : merge(state[state._conf.statePropName][doc.id], doc)\n    this._vm.$set(state[state._conf.statePropName], doc.id, newVal)\n  },\n  DELETE_DOC (state, id) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$delete(state[state._conf.statePropName], id)\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  const vuexEasyMutations = defaultMutations(state)\n  return Object.assign({}, vuexEasyMutations, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from './deepmerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj)\n}\n","import { isObject } from 'is-what'\n\nfunction retrievePaths (object, path, result) {\n  if (!isObject(object) || !Object.keys(object).length) {\n    if (!path) return object\n    result[path] = object\n    return result\n  }\n  return Object.keys(object).reduce((carry, key) => {\n    const pathUntilNow = (path)\n      ? path + '.'\n      : ''\n    const newPath = pathUntilNow + key\n    const extra = retrievePaths(object[key], newPath, result)\n    return Object.assign(carry, extra)\n  }, {})\n}\n\nexport default function (object) {\n  const result = {}\n  return retrievePaths(object, null, result)\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport { isArray, isString } from 'is-what'\nimport merge from '../utils/deepmerge'\nimport copyObj from '../utils/copyObj'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\nimport flattenToPaths from '../utils/objectFlattenToPaths'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], doc} = {ids: [], doc: {}}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) return console.log('ids needs to be an array')\n    if (id) ids.push(id)\n    if (doc.id) delete doc.id\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, doc)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state._sync.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(state._sync.syncStack.updates[id],\n                syncStackItems[id])\n      state._sync.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state._sync.syncStack.deletions.concat(syncStackIds)\n    state._sync.syncStack.deletions = deletions\n\n    if (!state._sync.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state._sync.syncStack.inserts.concat(syncStack)\n    state._sync.syncStack.inserts = inserts\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state._sync.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      state._sync.syncStack.debounceTimer = debounceTimer\n    }\n    state._sync.syncStack.debounceTimer.refresh()\n  },\n  batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state._sync.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state._sync.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = flattenToPaths(item.fields)\n      console.log('fields → ', fields)\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state._sync.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.deletions = deletionsLeft\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state._sync.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.inserts = insertsLeft\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    state._sync.syncStack.debounceTimer = null\n    return new Promise((resolve, reject) => {\n      batch.commit()\n      .then(res => {\n        console.log(`[batchSync] RESOLVED:`, res, `\n          updates: `, Object.keys(updates).length ? updates : {}, `\n          deletions: `, deletions.length ? deletions : [], `\n          inserts: `, inserts.length ? inserts : []\n        )\n        let remainingSyncStack = Object.keys(state._sync.syncStack.updates).length\n          + state._sync.syncStack.deletions.length\n          + state._sync.syncStack.inserts.length\n        if (remainingSyncStack) { dispatch('batchSync') }\n        dispatch('_stopPatching')\n        return resolve()\n        // // Fetch the item if it was added as an Archived item:\n        // if (item.archived) {\n          //   get_ters.dbRef.doc(res.id).get()\n          //   .then(doc => {\n            //     let tempId = doc.data().id\n            //     let id = doc.id\n            //     let item = doc.data()\n            //     item.id = id\n            //     console.log('retrieved Archived new item: ', id, item)\n            //     dispatch('newItemFromServer', {item, tempId})\n            //   })\n            // }\n      }).catch(error => {\n        state._sync.patching = 'error'\n        state._sync.syncStack.debounceTimer = null\n        return reject()\n      })\n    })\n  },\n  fetch (\n    {state, getters, commit, dispatch},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      const identifier = JSON.stringify({whereFilters, orderBy})\n      const fetched = state._sync.fetched[identifier]\n      // We've never fetched this before:\n      if (!fetched) {\n        let ref = getters.dbRef\n        // apply where filters and orderBy\n        whereFilters.forEach(paramsArr => {\n          ref = ref.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          ref = ref.orderBy(...orderBy)\n        }\n        state._sync.fetched[identifier] = {\n          ref,\n          done: false,\n          retrievedFetchRefs: [],\n          nextFetchRef: null\n        }\n      }\n      const fRequest = state._sync.fetched[identifier]\n      // We're already done fetching everything:\n      if (fRequest.done) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fRef = state._sync.fetched[identifier].ref\n      if (fRequest.nextFetchRef) {\n        // get next ref if saved in state\n        fRef = state._sync.fetched[identifier].nextFetchRef\n      }\n      fRef = fRef.limit(state._conf.fetch.docLimit)\n      // Stop if all records already fetched\n      if (fRequest.retrievedFetchRefs.includes(fRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          state._sync.fetched[identifier].done = true\n          resolve('fetchedAll')\n\n          return\n        }\n        if (docs.length < state._conf.fetch.docLimit) {\n          state._sync.fetched[identifier].done = true\n        }\n        state._sync.fetched[identifier].retrievedFetchRefs.push(fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fRef.startAfter(lastVisible)\n        state._sync.fetched[identifier].nextFetchRef = next\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    if (Firebase.auth().currentUser) state._sync.signedIn = true\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state._conf.firestoreRefType.toLowerCase() !== 'doc') {\n      state._conf.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state._conf.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state._conf.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn (_doc) {\n        return dispatch('serverUpdate', {change, id, doc: _doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state._conf.sync[change + 'Hook']\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, doc, id, this, source, change)\n      } else {\n        storeUpdateFn(doc)\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state._conf.serverChange.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state._conf.serverChange.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        state._sync.patching = 'error'\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (!doc.id || !state[state._conf.statePropName][doc.id]) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({state, getters, commit, dispatch}, doc) {\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('INSERT_DOC', _doc)\n      return dispatch('insertDoc', _doc)\n    }\n    // check for hooks\n    if (state._conf.insertHook) {\n      return state._conf.insertHook(storeUpdateFn, doc, this)\n    }\n    return storeUpdateFn(doc)\n  },\n  patch ({state, getters, commit, dispatch}, doc) {\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {id: _doc.id, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.patchHook) {\n      return state._conf.patchHook(storeUpdateFn, doc, this)\n    }\n    return storeUpdateFn(doc)\n  },\n  patchBatch (\n    {state, getters, commit, dispatch},\n    {doc, ids = []}\n  ) {\n    if (!doc) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {ids, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.patchHook) {\n      return state._conf.patchHook(storeUpdateFn, doc, this)\n    }\n    return storeUpdateFn(doc)\n  },\n  delete ({state, getters, commit, dispatch}, id) {\n    // define the store update\n    function storeUpdateFn (_id) {\n      commit('DELETE_DOC', _id)\n      return dispatch('deleteDoc', _id)\n    }\n    // check for hooks\n    if (state._conf.deleteHook) {\n      return state._conf.deleteHook(storeUpdateFn, id, this)\n    }\n    return storeUpdateFn(id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.stopPatchingTimeout = setTimeout(_ => { state._sync.patching = false }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.patching = true\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    return state._sync.signedIn\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    if (!Firebase.auth().currentUser) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state._conf.firestorePath.replace('{userId}', userId)\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state._conf.statePropName)\n      ? `${state._conf.moduleName}/${state._conf.statePropName}`\n      : state._conf.moduleName\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], doc = {}) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      let patchData = {}\n      // retrieve full object\n      if (!Object.keys(doc).length) {\n        patchData = (collectionMode)\n          ? getters.storeRef[id]\n          : getters.storeRef\n      } else {\n        patchData = doc\n      }\n      patchData = copyObj(patchData)\n      patchData = checkFillables(patchData, state._conf.sync.fillables, state._conf.sync.guard)\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      item = checkFillables(item, state._conf.sync.fillables, state._conf.sync.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","import merge from '../utils/deepmerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(defaultConfig, userConfig)\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.statePropName) docContainer[conf.statePropName] = {}\n  const state = merge(initialState, userState, docContainer, {_conf: conf})\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'moduleName']\n  reqProps.forEach(prop => {\n    if (!config[prop]) {\n      console.error(`Missing ${prop} from your config!`)\n      return false\n    }\n  })\n  if (/(\\.|\\/)/.test(config.statePropName)) {\n    console.error(`statePropName must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleName)) {\n    console.error(`moduleName must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleName = getKeysFromPath(config.moduleName)\n      store.registerModule(moduleName, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.patchBatch = (path, payload) => {\n      return store.dispatch(path + '/patchBatch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["nanoclone","require","default","toArray","object","result","i","length","push","types","el","type","merger","a","b","keys","Object","concat","forEach","key","Array","isArray","Math","max","merge","config","is","determineType","strategy","name","arguments","reduceRight","element","l","item","isObject","error","args","apply","updateStore","doc","store","id","source","change","mutations","state","_sync","syncStack","_conf","firestoreRefType","toLowerCase","_vm","$set","statePropName","newVal","undefined","$delete","copyObj","obj","newObj","prototype","toString","call","JSON","parse","stringify","len","hasOwnProperty","defaultValues","retrievePaths","path","reduce","carry","newPath","extra","assign","actions","getters","dispatch","commit","ids","console","log","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","ms","startTime","signedIn","debounceTimer","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","then","collectionMode","dbRef","batch","Firebase","firestore","count","updatesOriginal","map","k","fields","updatesOK","slice","updatesLeft","docRef","flattenToPaths","update","deletionsAmount","deletionsOK","deletionsLeft","delete","insertsAmount","insertsOK","insertsLeft","newRef","set","res","catch","patching","whereFilters","orderBy","identifier","fetched","ref","where","paramsArr","fRequest","fRef","nextFetchRef","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","fetchRef","lastVisible","next","startAfter","auth","currentUser","sync","handleDoc","storeUpdateFn","_doc","syncHookFn","this","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","serverChange","docChanges","insertHook","patchHook","_id","deleteHook","stopPatchingTimeout","setTimeout","fillables","guard","rootState","rootGetters","userId","uid","firestorePath","replace","collection","moduleName","getDeepRef","patchData","checkFillables","storeRef","updated_at","FieldValue","serverTimestamp","items","created_at","created_by","userConfig","conf","defaultConfig","prop","test","userState","userMutations","userActions","userGetters","docContainer","initialState","vuexEasyMutations","defaultMutations","iniMutations","iniActions","iniGetters","getKeysFromPath","registerModule","iniModule","setDoc","payload","insert","patch","patchBatch"],"mappings":"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"}