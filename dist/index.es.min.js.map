{"version":3,"file":"index.es.min.js","sources":["../node_modules/deepmerge/dist/es.js","../src/utils/deepmerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/utils/debounceHelper.js","../src/module/actions.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/errorCheck.js","../src/module/index.js","../src/index.js"],"sourcesContent":["var isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tObject.keys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tObject.keys(source).forEach(function(key) {\n\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = deepmerge(target[key], source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nexport default deepmerge_1;\n","import deepmerge from 'deepmerge'\n// import deepmerge from '../../node_modules/deepmerge/dist/es.js'\n\n/**\n * Makes sure to overwrite arrays completely instead of concatenating with a merge(). Usage: merge(arr1, arr2, {arrayOverwrite: true})\n *\n * @returns the latter array passed\n */\nfunction overwriteMerge (destinationArray, sourceArray, options) {\n  return sourceArray\n}\n\nfunction merge (a, b, options) {\n  if (options && options.arrayOverwrite) {\n    return deepmerge(a, b, {arrayMerge: overwriteMerge})\n  }\n  return deepmerge(a, b)\n}\n\nmerge.all = function (array, options) {\n  if (options && options.arrayOverwrite) {\n    return deepmerge.all(array, {arrayMerge: overwriteMerge})\n  }\n  return deepmerge.all(array)\n}\n\nexport default merge\n","\n/**\n * A function executed during the 2 way sync when docs are added/modified/deleted. NEEDS TO EXECUTE FIRST PARAM! You can use this function to do a conditional check on the documents to decide if/when to execute the store update.\n *\n * @param {function} storeUpdateFn this is the function that will make changes to your vuex store. Takes no params.\n * @param {object} store the store for usage with `store.dispatch`, `store.commit`, `store.getters` etc.\n * @param {string} id the doc id returned in `change.doc.id` (see firestore documentation for more info)\n * @param {object} doc the doc returned in `change.doc.data()` (see firestore documentation for more info)\n * @param {string} source of the change. Can be 'local' or 'server'\n */\nfunction syncHook (storeUpdateFn, store, id, doc, source, change) {\n  // throw error if you want to stop the document in your store from being modified\n  // do some stuff\n  storeUpdateFn()\n  // do some stuff\n}\n\nexport default {\n  moduleNameSpace: 'firestore',\n  // this is the vuex module path that will be created\n  docsStateProp: '',\n  // this is the state property where your docs will end up inside the module\n  // when not set your doc's props will be set directly to your vuex module's state\n  firestorePath: '',\n  // this is the firestore collection path to your documents. You can use `{userId}` which will be replaced with `Firebase.auth().uid`\n  firestoreRefType: 'collection', // or 'doc'\n  // depending if what you want to sync is a whole collection or a single doc\n  vuexUserPath: '',\n  // the path where your firebase user gets saved in vuex. Required to be able to have reactivity after login.\n  sync: {\n    type: '2way',\n    // '2way' only ('read only' not yet integrated)\n    where: [], // only applicable on 'collection'\n    orderBy: [], // only applicable on 'collection'\n    defaultValues: {},\n    // About defaultValues:\n    // These are the default properties that will be set on each doc that's synced to the store or comes out of the store.\n    // You HAVE to set all props you want to be reactive on beforehand!\n    // These values are only set when you have items who don't have the props defined in defaultValues upon retrieval\n    // The retrieved document will be deep merged on top of these default values\n    added: syncHook,\n    modified: syncHook,\n    removed: syncHook,\n    // see the syncHook function above to see what you can do\n    // for firestoreRefType: 'doc' only use 'modified' syncHook\n  },\n  fetch: {\n    docLimit: 50, // defaults to 50\n  },\n  insert: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (doc, docs) { return (doc.something != 'something') },\n    fillables: [],\n    guard: [],\n  },\n  patch: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (id, fields, docs) { return (doc.something != 'something') },\n    fillables: [],\n    guard: [],\n  },\n  delete: {\n    checkCondition: null,\n    // A function where you can check something and force stopping the operation if you return `false`\n    // Eg. checkCondition (id, docs) { return (doc.something != 'something') },\n  }\n}\n","\nexport default {\n  // user: null,\n  syncStack: {\n    updates: {},\n    deletions: [],\n    inserts: [],\n    debounceTimer: null\n  },\n  retrievedFetchRefs: [],\n  nextFetchRef: null,\n  patching: false,\n  doneFetching: false,\n  stopPatchingTimeout: null,\n}\n","import { defaultMutations } from 'vuex-easy-access'\nimport { isObject } from 'is-what'\nimport merge from '../utils/deepmerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$set(state[state.docsStateProp], doc.id, doc)\n  },\n  PATCH_DOC (state, doc) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') {\n      if (!state.docsStateProp) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined)\n            ? doc[key]\n            : (!isObject(state[key]) || !isObject(doc[key]))\n              ? doc[key]\n              : merge(state[key], doc[key], {arrayOverwrite: true})\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state.docsStateProp] will always be an empty object by default\n      state[state.docsStateProp] = merge(\n        state[state.docsStateProp],\n        doc,\n        {arrayOverwrite: true}\n      )\n      return\n    }\n    // Merge if exists\n    const newVal = (state[state.docsStateProp][doc.id] === undefined)\n      ? doc\n      : (!isObject(state[state.docsStateProp][doc.id]) || !isObject(doc))\n        ? doc\n        : merge(state[state.docsStateProp][doc.id], doc, {arrayOverwrite: true})\n    this._vm.$set(state[state.docsStateProp], doc.id, newVal)\n  },\n  DELETE_DOC (state, id) {\n    if (state.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$delete(state[state.docsStateProp], id)\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  const vuexEasyMutations = defaultMutations(state)\n  return Object.assign({}, vuexEasyMutations, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from './deepmerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj, {arrayOverwrite: true})\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport { isArray, isString } from 'is-what'\nimport merge from '../utils/deepmerge'\nimport copyObj from '../utils/copyObj'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], field = '', fields = []} = {ids: [], fields: []}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids) || !isArray(fields)) return console.log('ids, fields need to be arrays')\n    if (!isString(field)) return console.log('field needs to be a string')\n    if (id) ids.push(id)\n    if (field) fields.push(field)\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, fields)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(\n            state.syncStack.updates[id],\n            syncStackItems[id],\n            {arrayOverwrite: true}\n          )\n      state.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state.syncStack.deletions.concat(syncStackIds)\n    commit('SET_SYNCSTACK.DELETIONS', deletions)\n\n    if (!state.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state.syncStack.inserts.concat(syncStack)\n    commit('SET_SYNCSTACK.INSERTS', inserts)\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      commit('SET_SYNCSTACK.DEBOUNCETIMER', debounceTimer)\n    }\n    state.syncStack.debounceTimer.refresh()\n  },\n  batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = item.fields\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      commit('SET_SYNCSTACK.DELETIONS', deletionsLeft)\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      commit('SET_SYNCSTACK.INSERTS', insertsLeft)\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    commit('SET_SYNCSTACK.DEBOUNCETIMER', null)\n    return new Promise((resolve, reject) => {\n      batch.commit()\n      .then(res => {\n        console.log(`[batchSync] RESOLVED:`, res, `\n          updates: `, Object.keys(updates).length ? updates : {}, `\n          deletions: `, deletions.length ? deletions : [], `\n          inserts: `, inserts.length ? inserts : []\n        )\n        let remainingSyncStack = Object.keys(state.syncStack.updates).length\n          + state.syncStack.deletions.length\n          + state.syncStack.inserts.length\n        if (remainingSyncStack) { dispatch('batchSync') }\n        dispatch('_stopPatching')\n        return resolve()\n        // // Fetch the item if it was added as an Archived item:\n        // if (item.archived) {\n          //   get_ters.dbRef.doc(res.id).get()\n          //   .then(doc => {\n            //     let tempId = doc.data().id\n            //     let id = doc.id\n            //     let item = doc.data()\n            //     item.id = id\n            //     console.log('retrieved Archived new item: ', id, item)\n            //     dispatch('newItemFromServer', {item, tempId})\n            //   })\n            // }\n      }).catch(error => {\n        commit('SET_PATCHING', 'error')\n        commit('SET_SYNCSTACK.DEBOUNCETIMER', null)\n        return reject()\n      })\n    })\n  },\n  fetch (\n    {state, getters, commit},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      if (state.doneFetching) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fetchRef\n      if (state.nextFetchRef) {\n        // get next ref if saved in state\n        fetchRef = state.nextFetchRef\n      } else {\n        // apply where filters and orderBy\n        fetchRef = getters.dbRef\n        whereFilters.forEach(paramsArr => {\n          fetchRef = fetchRef.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          fetchRef = fetchRef.orderBy(...orderBy)\n        }\n      }\n      fetchRef = fetchRef.limit(state.fetch.docLimit)\n      // Stop if all records already fetched\n      if (state.retrievedFetchRefs.includes(fetchRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fetchRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          commit('SET_DONEFETCHING', true)\n          return resolve('fetchedAll')\n        }\n        if (docs.length < state.fetch.docLimit) {\n          commit('SET_DONEFETCHING', true)\n        }\n        commit('PUSH_RETRIEVEDFETCHREFS', fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fetchRef.startAfter(lastVisible)\n        commit('SET_NEXTFETCHREF', next)\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state.firestoreRefType.toLowerCase() !== 'doc') {\n      state.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn () {\n        return dispatch('serverUpdate', {change, id, doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state.sync[change]\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, this, id, doc, source)\n      } else {\n        storeUpdateFn()\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state.sync.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state.sync.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        commit('SET_PATCHING', 'error')\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (!doc.id || !state[state.docsStateProp][doc.id]) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({commit, dispatch, getters}, doc) {\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    commit('INSERT_DOC', doc)\n    return dispatch('insertDoc', doc)\n  },\n  patch ({commit, state, dispatch, getters}, doc) {\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    commit('PATCH_DOC', doc)\n    return dispatch('patchDoc', {id: doc.id, fields: Object.keys(doc)})\n  },\n  delete ({commit, dispatch, getters}, id) {\n    commit('DELETE_DOC', id)\n    return dispatch('deleteDoc', id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state.stopPatchingTimeout) { clearTimeout(state.stopPatchingTimeout) }\n    state.stopPatchingTimeout = setTimeout(_ => { commit('SET_PATCHING', false) }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state.stopPatchingTimeout) { clearTimeout(state.stopPatchingTimeout) }\n    commit('SET_PATCHING', true)\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    const user = getDeepRef(rootState, state.vuexUserPath)\n    return (user !== null)\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state.firestorePath.replace('{userId}', userId)\n    return (state.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state.docsStateProp)\n      ? `${state.moduleNameSpace}/${state.docsStateProp}`\n      : state.moduleNameSpace\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], fields = []) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      // Accept an extra condition to check\n      const check = state.patch.checkCondition\n      if (check && !check(id, fields, getters.storeRef)) return carry\n\n      let patchData = {}\n      // Patch specific fields only\n      if (fields.length) {\n        fields.forEach(field => {\n          patchData[field] = (collectionMode)\n            ? getters.storeRef[id][field]\n            : getters.storeRef[field]\n        })\n      // Patch the whole item\n      } else {\n        patchData = (collectionMode)\n          ? copyObj(getters.storeRef[id])\n          : copyObj(getters.storeRef)\n        patchData = checkFillables(patchData, state.patch.fillables, state.patch.guard)\n      }\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      // Accept an extra condition to check\n      let check = state.delete.checkCondition\n      if (check && !check(id, getters.storeRef)) return carry\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      // Accept an extra condition to check\n      let check = state.insert.checkCondition\n      if (check && !check(item, getters.storeRef)) return carry\n\n      item = checkFillables(item, state.insert.fillables, state.insert.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'vuexUserPath']\n  reqProps.forEach(prop => {\n    console.error(`Missing ${prop} from your config!`)\n    return false\n  })\n  if (/(\\.|\\/)/.test(config.docsStateProp)) {\n    console.error(`docsStateProp must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleNameSpace)) {\n    console.error(`moduleNameSpace must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import merge from '../utils/deepmerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\nconst vuexBase = {state: null, mutations: null, actions: null, getters: null}\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(vuexBase, userConfig, {arrayOverwrite: true})\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.docsStateProp) docContainer[conf.docsStateProp] = {}\n  const state = merge.all([initialState, defaultConfig, userState, conf, docContainer], {arrayOverwrite: true})\n\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleNameSpace = getKeysFromPath(config.moduleNameSpace)\n      store.registerModule(moduleNameSpace, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["isMergeableObject","value","isNonNullObject","isSpecial","stringValue","Object","prototype","toString","call","isReactElement","canUseSymbol","Symbol","for","REACT_ELEMENT_TYPE","$$typeof","emptyTarget","val","Array","isArray","cloneUnlessOtherwiseSpecified","options","clone","deepmerge","defaultArrayMerge","target","source","concat","map","element","mergeObject","destination","keys","forEach","key","arrayMerge","sourceIsArray","all","array","Error","reduce","prev","next","deepmerge_1","overwriteMerge","destinationArray","sourceArray","merge","a","b","arrayOverwrite","syncHook","storeUpdateFn","store","id","doc","change","mutations","state","syncStack","firestoreRefType","toLowerCase","_vm","$set","docsStateProp","newVal","undefined","isObject","$delete","userMutations","vuexEasyMutations","defaultMutations","assign","copyObj","obj","newObj","JSON","parse","stringify","i","len","length","hasOwnProperty","defaultValues","ms","startTime","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","actions","getters","dispatch","commit","ids","fields","field","console","log","isString","push","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","signedIn","debounceTimer","startDebounce","then","collectionMode","dbRef","batch","Firebase","firestore","count","updatesOriginal","k","updatesOK","slice","updatesLeft","carry","item","docRef","update","deletionsAmount","deletionsOK","deletionsLeft","delete","insertsAmount","insertsOK","insertsLeft","newRef","set","res","catch","whereFilters","orderBy","doneFetching","fetchRef","nextFetchRef","where","paramsArr","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","lastVisible","startAfter","error","sync","handleDoc","type","syncHookFn","this","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","docChanges","stopPatchingTimeout","setTimeout","userActions","fillables","guard","rootState","rootGetters","getDeepRef","vuexUserPath","userId","auth","currentUser","uid","path","firestorePath","replace","collection","moduleNameSpace","check","patch","checkCondition","storeRef","patchData","checkFillables","updated_at","FieldValue","serverTimestamp","items","insert","created_at","created_by","userGetters","errorCheck","config","prop","test","vuexBase","userConfig","conf","userState","docContainer","initialState","defaultConfig","iniMutations","iniActions","iniGetters","createEasyFirestore","getKeysFromPath","registerModule","iniModule","setDoc","payload"],"mappings":"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"}