{"version":3,"file":"index.cjs.min.js","sources":["../src/utils/nanomerge.js","../src/utils/deepmerge.js","../src/module/defaultConfig.js","../src/module/state.js","../src/module/mutations.js","../src/utils/copyObj.js","../src/utils/setDefaultValues.js","../src/utils/debounceHelper.js","../src/utils/objectFlattenToPaths.js","../src/module/actions.js","../src/utils/checkFillables.js","../src/module/getters.js","../src/module/errorCheck.js","../src/module/index.js","../src/index.js"],"sourcesContent":["var nanoclone = require('nanoclone').default\n\nfunction toArray (object) {\n  var result = []\n\n  for (var i = 0; i < object.length; ++i) {\n    result.push(object[i])\n  }\n\n  return result\n}\n\nvar types = [\n  {\n    name: 'primitive',\n\n    is: function (el) {\n      var type = typeof el\n\n      return (type === 'number' || type === 'string' || type === 'boolean')\n    },\n\n    default: 'default',\n\n    merge: {\n      default: function (merger, a, b) {\n        return b\n      }\n    }\n  },\n\n  {\n    name: 'object',\n\n    is: function (el) {\n      return el !== null && (typeof el === 'object')\n    },\n\n    default: 'deep',\n\n    merge: {\n      deep: function (merger, a, b) {\n        var result = {}\n\n        var keys = {\n          a: Object.keys(a),\n          b: Object.keys(b)\n        }\n\n        keys.a.concat(keys.b).forEach(function (key) {\n          result[key] = merger(a[key], b[key])\n        })\n\n        return result\n      }\n    }\n  },\n\n  {\n    name: 'array',\n\n    is: function (el) {\n      return Array.isArray(el)\n    },\n\n    default: 'replace',\n\n    merge: {\n      merge: function (merger, a, b) {\n        var result = []\n\n        for (var i = 0; i < Math.max(a.length, b.length); ++i) {\n          result.push(merger(a[i], b[i]))\n        }\n\n        return result\n      },\n\n      replace: function (merger, a, b) {\n        return nanoclone(b)\n      },\n\n      concat: function (merger, a, b) {\n        return (([]).concat(a)).concat(b)\n      }\n    }\n  }\n]\n\nfunction merge (config) {\n  if (!config) {\n    config = {}\n  }\n\n  config = {\n    strategy: config.strategy || {}\n  }\n\n  function determineType (a, b) {\n    for (var i = types.length - 1; i >= 0; --i) {\n      var type = types[i]\n\n      if (type.is(a) && type.is(b)) {\n        return type\n      } else if (type.is(a) || type.is(b)) {\n        break\n      }\n    }\n\n    return null\n  }\n\n  function merger (a, b) {\n    if (b === void 0) {\n      return nanoclone(a)\n    }\n\n    var type = determineType(a, b)\n\n    if (!type) {\n      return nanoclone(b)\n    }\n\n    var strategy = config.strategy[type.name] || type.default\n\n    return type.merge[strategy](merger, a, b)\n  }\n\n  return function () {\n    var elements = toArray(arguments)\n\n    return elements.reduceRight(function (result, element) {\n      return merger(element, result)\n    })\n  }\n}\n\nfunction wrapper () {\n  var args = toArray(arguments)\n\n  // custom config\n  if (args.length === 1) {\n    return merge(args[0])\n  }\n\n  return merge().apply(null, args)\n}\n\nexport default wrapper\n// module.exports = wrapper\n","import { isObject } from 'is-what'\nimport deepmerge from './nanomerge'\n\nfunction merge (...params) {\n  let l = params.length\n  for (l; l > 0; l--) {\n    const item = params[l - 1]\n    if (!isObject(item)) {\n      console.error('trying to merge a non-object: ', item)\n      return item\n    }\n  }\n  return deepmerge(...params)\n}\n\nexport default merge\n","\nexport default {\n  firestorePath: '',\n    // The path to a collection or doc in firestore. You can use `{userId}` which will be replaced with the user Id.\n  firestoreRefType: '',\n    // `'collection'` or `'doc'`. Depending on your `firestorePath`.\n  moduleName: '',\n    // The module name. Can be nested, eg. `'user/items'`\n  statePropName: '',\n    // The name of the property where the docs or doc will be synced to. If left blank it will be synced on the state of the module. (Please see [Sync directly to module state](#sync-directly-to-module-state) for more info)\n\n  // Related to the 2-way sync:\n  sync: {\n    where: [],\n    orderBy: [],\n    fillables: [],\n    guard: [],\n  },\n\n  // HOOKS:\n  insertHook: function (updateStore, doc, store) { return updateStore(doc) },\n  patchHook: function (updateStore, doc, store) { return updateStore(doc) },\n  deleteHook: function (updateStore, id, store) { return updateStore(id) },\n\n  // When items on the server side are changed:\n  serverChange: {\n    defaultValues: {},\n    // HOOKS for changes on SERVER:\n    addedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    modifiedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n    removedHook: function (updateStore, doc, id, store, source, change) { return updateStore(doc) },\n  },\n\n  // When items are fetched through `dispatch('module/fetch', filters)`.\n  fetch: {\n    // The max amount of documents to be fetched. Defaults to 50.\n    docLimit: 50,\n  },\n\n  // You can also add custom state/getters/mutations/actions. These will be added to your module.\n  state: {},\n  getters: {},\n  mutations: {},\n  actions: {},\n}\n","\nexport default {\n  _sync: {\n    signedIn: false,\n    patching: false,\n    syncStack: {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    },\n    fetched: [],\n    stopPatchingTimeout: null\n  }\n}\n","import { defaultMutations } from 'vuex-easy-access'\nimport { isObject } from 'is-what'\nimport merge from '../utils/deepmerge'\n\nconst mutations = {\n  resetSyncStack (state) {\n    state._sync.syncStack = {\n      updates: {},\n      deletions: [],\n      inserts: [],\n      debounceTimer: null\n    }\n  },\n  INSERT_DOC (state, doc) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$set(state[state._conf.statePropName], doc.id, doc)\n  },\n  PATCH_DOC (state, doc) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') {\n      if (!state._conf.statePropName) {\n        return Object.keys(doc).forEach(key => {\n          // Merge if exists\n          const newVal = (state[key] === undefined)\n            ? doc[key]\n            : (!isObject(state[key]) || !isObject(doc[key]))\n              ? doc[key]\n              : merge(state[key], doc[key])\n          this._vm.$set(state, key, newVal)\n        })\n      }\n      // state[state._conf.statePropName] will always be an empty object by default\n      state[state._conf.statePropName] = merge(state[state._conf.statePropName], doc)\n      return\n    }\n    // Merge if exists\n    const newVal = (state[state._conf.statePropName][doc.id] === undefined)\n      ? doc\n      : (!isObject(state[state._conf.statePropName][doc.id]) || !isObject(doc))\n        ? doc\n        : merge(state[state._conf.statePropName][doc.id], doc)\n    this._vm.$set(state[state._conf.statePropName], doc.id, newVal)\n  },\n  DELETE_DOC (state, id) {\n    if (state._conf.firestoreRefType.toLowerCase() === 'doc') return\n    this._vm.$delete(state[state._conf.statePropName], id)\n  }\n}\n\nexport default function (userMutations = {}, state) {\n  const vuexEasyMutations = defaultMutations(state)\n  return Object.assign({}, vuexEasyMutations, mutations, userMutations)\n}\n","/**\n * copyObj helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\nexport default function copyObj (obj) {\n  let newObj\n  if (typeof obj != 'object') {\n    return obj\n  }\n  if (!obj) {\n    return obj\n  }\n  if ('[object Object]' !== Object.prototype.toString.call(obj) ||\n    '[object Array]' !== Object.prototype.toString.call(obj)\n  ) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  // Object is an Array\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    newObj = []\n    for (let i = 0, len = obj.length; i < len; i++) {\n      newObj[i] = copyObj(obj[i])\n    }\n    return newObj\n  }\n  // Object is an Object\n  newObj = {}\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = copyObj(obj[i])\n    }\n  }\n  return newObj\n}\n","import merge from './deepmerge'\n\n/**\n * Sets default values on an object\n *\n * @param {object} obj on which to set the default values\n * @param {object} defaultValues the default values\n */\nexport default function (obj, defaultValues) {\n  return merge(defaultValues, obj)\n}\n","/**\n * debounce helper\n *\n * @author     Adam Dorling\n * @contact    https://codepen.io/naito\n */\n\n// USAGE:\n// let d = startDebounce(1000)\n// d.done.then(_ => handle())\n// d.refresh() // to refresh\n\nexport default function (ms) {\n  let startTime = Date.now()\n  const done = new Promise((resolve, reject) => {\n    const interval = setInterval(_ => {\n      const now = Date.now()\n      const deltaT = now - startTime\n      if (deltaT >= ms) {\n        clearInterval(interval)\n        resolve(true)\n      }\n    }, 10)\n  })\n  const refresh = () => (startTime = Date.now())\n  return { done, refresh }\n}\n","import { isObject } from 'is-what'\n\nfunction retrievePaths (object, path, result) {\n  if (!isObject(object) || !Object.keys(object).length) {\n    if (!path) return object\n    result[path] = object\n    return result\n  }\n  return Object.keys(object).reduce((carry, key) => {\n    const pathUntilNow = (path)\n      ? path + '.'\n      : ''\n    const newPath = pathUntilNow + key\n    const extra = retrievePaths(object[key], newPath, result)\n    return Object.assign(carry, extra)\n  }, {})\n}\n\nexport default function (object) {\n  const result = {}\n  return retrievePaths(object, null, result)\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport { isArray, isString } from 'is-what'\nimport merge from '../utils/deepmerge'\nimport copyObj from '../utils/copyObj'\nimport setDefaultValues from '../utils/setDefaultValues'\nimport startDebounce from '../utils/debounceHelper'\nimport flattenToPaths from '../utils/objectFlattenToPaths'\n\nconst actions = {\n  patchDoc (\n    {state, getters, commit, dispatch},\n    {id = '', ids = [], doc} = {ids: [], doc: {}}\n  ) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) return console.log('ids needs to be an array')\n    if (id) ids.push(id)\n    if (doc.id) delete doc.id\n\n    // 1. Prepare for patching\n    let syncStackItems = getters.prepareForPatch(ids, doc)\n\n    // 2. Push to syncStack\n    Object.keys(syncStackItems).forEach(id => {\n      const newVal = (!state._sync.syncStack.updates[id])\n        ? syncStackItems[id]\n        : merge(state._sync.syncStack.updates[id],\n                syncStackItems[id])\n      state._sync.syncStack.updates[id] = newVal\n    })\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  deleteDoc ({state, getters, commit, dispatch},\n  ids = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(ids)) ids = [ids]\n\n    // 1. Prepare for patching\n    const syncStackIds = getters.prepareForDeletion(ids)\n\n    // 2. Push to syncStack\n    const deletions = state._sync.syncStack.deletions.concat(syncStackIds)\n    state._sync.syncStack.deletions = deletions\n\n    if (!state._sync.syncStack.deletions.length) return\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  insertDoc ({state, getters, commit, dispatch},\n  docs = []) {\n    // 0. payload correction (only arrays)\n    if (!isArray(docs)) docs = [docs]\n\n    // 1. Prepare for patching\n    const syncStack = getters.prepareForInsert(docs)\n\n    // 2. Push to syncStack\n    const inserts = state._sync.syncStack.inserts.concat(syncStack)\n    state._sync.syncStack.inserts = inserts\n\n    // 3. Create or refresh debounce\n    return dispatch('handleSyncStackDebounce')\n  },\n  handleSyncStackDebounce ({state, commit, dispatch, getters}) {\n    if (!getters.signedIn) return false\n    if (!state._sync.syncStack.debounceTimer) {\n      const debounceTimer = startDebounce(1000)\n      debounceTimer.done.then(_ => dispatch('batchSync'))\n      state._sync.syncStack.debounceTimer = debounceTimer\n    }\n    state._sync.syncStack.debounceTimer.refresh()\n  },\n  batchSync ({getters, commit, dispatch, state}) {\n    const collectionMode = getters.collectionMode\n    const dbRef = getters.dbRef\n    let batch = Firebase.firestore().batch()\n    let count = 0\n    // Add 'updateds' to batch\n    let updatesOriginal = copyObj(state._sync.syncStack.updates)\n    let updates = Object.keys(updatesOriginal).map(k => {\n      let fields = updatesOriginal[k]\n      return {id: k, fields}\n    })\n    // Check if there are more than 500 batch items already\n    if (updates.length >= 500) {\n      // Batch supports only until 500 items\n      count = 500\n      let updatesOK = updates.slice(0, 500)\n      let updatesLeft = updates.slice(500, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.updates = updatesLeft.reduce((carry, item) => {\n        carry[item.id] = item\n        delete item.id\n        return carry\n      }, {})\n      updates = updatesOK\n    } else {\n      state._sync.syncStack.updates = {}\n      count = updates.length\n    }\n    // Add to batch\n    updates.forEach(item => {\n      let id = item.id\n      let docRef = (collectionMode) ? dbRef.doc(id) : dbRef\n      let fields = flattenToPaths(item.fields)\n      console.log('fields → ', fields)\n      batch.update(docRef, fields)\n    })\n    // Add 'deletions' to batch\n    let deletions = copyObj(state._sync.syncStack.deletions)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      deletions = []\n    } else {\n      // Batch supports only until 500 items\n      let deletionsAmount = 500 - count\n      let deletionsOK = deletions.slice(0, deletionsAmount)\n      let deletionsLeft = deletions.slice(deletionsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.deletions = deletionsLeft\n      count = count + deletionsOK.length\n      // Define the items we'll add below\n      deletions = deletionsOK\n    }\n    // Add to batch\n    deletions.forEach(id => {\n      let docRef = dbRef.doc(id)\n      batch.delete(docRef)\n    })\n    // Add 'inserts' to batch\n    let inserts = copyObj(state._sync.syncStack.inserts)\n    // Check if there are more than 500 batch items already\n    if (count >= 500) {\n      // already at 500 or more, leave items in syncstack, and don't add anything to batch\n      inserts = []\n    } else {\n      // Batch supports only until 500 items\n      let insertsAmount = 500 - count\n      let insertsOK = inserts.slice(0, insertsAmount)\n      let insertsLeft = inserts.slice(insertsAmount, -1)\n      // Put back the remaining items over 500\n      state._sync.syncStack.inserts = insertsLeft\n      count = count + insertsOK.length\n      // Define the items we'll add below\n      inserts = insertsOK\n    }\n    // Add to batch\n    inserts.forEach(item => {\n      let newRef = getters.dbRef.doc(item.id)\n      batch.set(newRef, item)\n    })\n    // Commit the batch:\n    // console.log(`[batchSync] START:\n    //   ${Object.keys(updates).length} updates,\n    //   ${deletions.length} deletions,\n    //   ${inserts.length} inserts`\n    // )\n    dispatch('_startPatching')\n    state._sync.syncStack.debounceTimer = null\n    return new Promise((resolve, reject) => {\n      batch.commit()\n      .then(res => {\n        console.log(`[batchSync] RESOLVED:`, res, `\n          updates: `, Object.keys(updates).length ? updates : {}, `\n          deletions: `, deletions.length ? deletions : [], `\n          inserts: `, inserts.length ? inserts : []\n        )\n        let remainingSyncStack = Object.keys(state._sync.syncStack.updates).length\n          + state._sync.syncStack.deletions.length\n          + state._sync.syncStack.inserts.length\n        if (remainingSyncStack) { dispatch('batchSync') }\n        dispatch('_stopPatching')\n        return resolve()\n        // // Fetch the item if it was added as an Archived item:\n        // if (item.archived) {\n          //   get_ters.dbRef.doc(res.id).get()\n          //   .then(doc => {\n            //     let tempId = doc.data().id\n            //     let id = doc.id\n            //     let item = doc.data()\n            //     item.id = id\n            //     console.log('retrieved Archived new item: ', id, item)\n            //     dispatch('newItemFromServer', {item, tempId})\n            //   })\n            // }\n      }).catch(error => {\n        state._sync.patching = 'error'\n        state._sync.syncStack.debounceTimer = null\n        return reject()\n      })\n    })\n  },\n  fetch (\n    {state, getters, commit, dispatch},\n    {whereFilters = [], orderBy = []} = {whereFilters: [], orderBy: []}\n    // whereFilters: [['archived', '==', true]]\n    // orderBy: ['done_date', 'desc']\n  ) {\n    return new Promise((resolve, reject) => {\n      console.log('[fetch] starting')\n      if (!getters.signedIn) return resolve()\n      const identifier = JSON.stringify({whereFilters, orderBy})\n      const fetched = state._sync.fetched[identifier]\n      // We've never fetched this before:\n      if (!fetched) {\n        let ref = getters.dbRef\n        // apply where filters and orderBy\n        whereFilters.forEach(paramsArr => {\n          ref = ref.where(...paramsArr)\n        })\n        if (orderBy.length) {\n          ref = ref.orderBy(...orderBy)\n        }\n        state._sync.fetched[identifier] = {\n          ref,\n          done: false,\n          retrievedFetchRefs: [],\n          nextFetchRef: null\n        }\n      }\n      const fRequest = state._sync.fetched[identifier]\n      // We're already done fetching everything:\n      if (fRequest.done) {\n        console.log('done fetching')\n        return resolve('fetchedAll')\n      }\n      // attach fetch filters\n      let fRef = state._sync.fetched[identifier].ref\n      if (fRequest.nextFetchRef) {\n        // get next ref if saved in state\n        fRef = state._sync.fetched[identifier].nextFetchRef\n      }\n      fRef = fRef.limit(state._conf.fetch.docLimit)\n      // Stop if all records already fetched\n      if (fRequest.retrievedFetchRefs.includes(fRef)) {\n        console.log('Already retrieved this part.')\n        return resolve()\n      }\n      // make fetch request\n      fRef.get()\n      .then(querySnapshot => {\n        const docs = querySnapshot.docs\n        if (docs.length === 0) {\n          state._sync.fetched[identifier].done = true\n          resolve('fetchedAll')\n\n          return\n        }\n        if (docs.length < state._conf.fetch.docLimit) {\n          state._sync.fetched[identifier].done = true\n        }\n        state._sync.fetched[identifier].retrievedFetchRefs.push(fetchRef)\n        // Get the last visible document\n        resolve(querySnapshot)\n        const lastVisible = docs[docs.length - 1]\n        // get the next records.\n        const next = fRef.startAfter(lastVisible)\n        state._sync.fetched[identifier].nextFetchRef = next\n      }).catch(error => {\n        console.log(error)\n        return reject(error)\n      })\n    })\n  },\n  serverUpdate ({commit}, {change, id, doc = {}}) {\n    doc.id = id\n    switch (change) {\n      case 'added':\n        commit('INSERT_DOC', doc)\n        break\n      case 'removed':\n        commit('DELETE_DOC', id)\n        break\n      default:\n        commit('PATCH_DOC', doc)\n        break\n    }\n  },\n  openDBChannel ({getters, state, commit, dispatch}) {\n    if (Firebase.auth().currentUser) state._sync.signedIn = true\n    const collectionMode = getters.collectionMode\n    let dbRef = getters.dbRef\n    // apply where filters and orderBy\n    if (state._conf.firestoreRefType.toLowerCase() !== 'doc') {\n      state._conf.sync.where.forEach(paramsArr => {\n        dbRef = dbRef.where(...paramsArr)\n      })\n      if (state._conf.sync.orderBy.length) {\n        dbRef = dbRef.orderBy(...state._conf.sync.orderBy)\n      }\n    }\n    // define handleDoc()\n    function handleDoc (change, id, doc, source) {\n      change = (!change) ? 'modified' : change.type\n      // define storeUpdateFn()\n      function storeUpdateFn (_doc) {\n        return dispatch('serverUpdate', {change, id, doc: _doc})\n      }\n      // get user set sync hook function\n      const syncHookFn = state._conf.sync[change + 'Hook']\n      if (syncHookFn) {\n        syncHookFn(storeUpdateFn, doc, id, this, source, change)\n      } else {\n        storeUpdateFn(doc)\n      }\n    }\n    // make a promise\n    return new Promise ((resolve, reject) => {\n      dbRef\n      .onSnapshot(querySnapshot => {\n        let source = querySnapshot.metadata.hasPendingWrites ? 'local' : 'server'\n        if (!collectionMode) {\n          const doc = setDefaultValues(querySnapshot.data(), state._conf.serverChange.defaultValues)\n          if (source === 'local') return resolve()\n          handleDoc(null, null, doc, source)\n          return resolve()\n        }\n        querySnapshot.docChanges().forEach(change => {\n          // Don't do anything for local modifications & removals\n          if (source === 'local' &&\n            (change.type === 'modified' || change.type === 'removed')\n          ) {\n            return resolve()\n          }\n          const id = change.doc.id\n          const doc = (change.type === 'added')\n            ? setDefaultValues(change.doc.data(), state._conf.serverChange.defaultValues)\n            : change.doc.data()\n          handleDoc(change, id, doc, source)\n          return resolve()\n        })\n      }, error => {\n        state._sync.patching = 'error'\n        return reject(error)\n      })\n    })\n  },\n  set ({commit, dispatch, getters, state}, doc) {\n    if (!doc) return\n    if (!getters.collectionMode) {\n      return dispatch('patch', doc)\n    }\n    if (!doc.id || !state[state._conf.statePropName][doc.id]) {\n      return dispatch('insert', doc)\n    }\n    return dispatch('patch', doc)\n  },\n  insert ({state, getters, commit, dispatch}, doc) {\n    if (!doc) return\n    if (!doc.id) doc.id = getters.dbRef.doc().id\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('INSERT_DOC', _doc)\n      return dispatch('insertDoc', _doc)\n    }\n    // check for hooks\n    if (state._conf.insertHook) {\n      return state._conf.insertHook(storeUpdateFn, doc, this)\n    }\n    return storeUpdateFn(doc)\n  },\n  patch ({state, getters, commit, dispatch}, doc) {\n    if (!doc) return\n    if (!doc.id && getters.collectionMode) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {id: _doc.id, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.patchHook) {\n      return state._conf.patchHook(storeUpdateFn, doc, this)\n    }\n    return storeUpdateFn(doc)\n  },\n  patchBatch (\n    {state, getters, commit, dispatch},\n    {doc, ids = []}\n  ) {\n    if (!doc) return\n    // define the store update\n    function storeUpdateFn (_doc) {\n      commit('PATCH_DOC', _doc)\n      return dispatch('patchDoc', {ids, doc: _doc})\n    }\n    // check for hooks\n    if (state._conf.patchHook) {\n      return state._conf.patchHook(storeUpdateFn, doc, this)\n    }\n    return storeUpdateFn(doc)\n  },\n  delete ({state, getters, commit, dispatch}, id) {\n    // define the store update\n    function storeUpdateFn (_id) {\n      commit('DELETE_DOC', _id)\n      return dispatch('deleteDoc', _id)\n    }\n    // check for hooks\n    if (state._conf.deleteHook) {\n      return state._conf.deleteHook(storeUpdateFn, id, this)\n    }\n    return storeUpdateFn(id)\n  },\n  _stopPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.stopPatchingTimeout = setTimeout(_ => { state._sync.patching = false }, 300)\n  },\n  _startPatching ({state, commit}) {\n    if (state._sync.stopPatchingTimeout) { clearTimeout(state._sync.stopPatchingTimeout) }\n    state._sync.patching = true\n  }\n}\n\nexport default function (userActions = {}) {\n  return Object.assign({}, actions, userActions)\n}\n","\nimport { isObject } from 'is-what'\n/**\n * Checks all props of an object and deletes guarded and non-fillables.\n *\n * @param {object}  obj       the target object to check\n * @param {array}   fillables an array of strings, with the props which should be allowed on returned object\n * @param {array}   guard     an array of strings, with the props which should NOT be allowed on returned object\n *\n * @returns {object} the cleaned object after deleting guard and non-fillables\n */\nexport default function (obj, fillables = [], guard = []) {\n  if (!isObject(obj)) return obj\n  if (fillables.length) {\n    Object.keys(obj).forEach(key => {\n      if (!fillables.includes(key)) {\n        delete obj[key]\n      }\n    })\n  }\n  guard.forEach(key => {\n    delete obj[key]\n  })\n  return obj\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/firestore'\nimport 'firebase/auth'\nimport copyObj from '../utils/copyObj'\nimport { getDeepRef } from 'vuex-easy-access'\nimport checkFillables from '../utils/checkFillables'\n\nconst getters = {\n  signedIn: (state, getters, rootState, rootGetters) => {\n    return state._sync.signedIn\n  },\n  dbRef: (state, getters, rootState, rootGetters) => {\n    if (!getters.signedIn) return false\n    if (!Firebase.auth().currentUser) return false\n    const userId = Firebase.auth().currentUser.uid\n    const path = state._conf.firestorePath.replace('{userId}', userId)\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n      ? Firebase.firestore().collection(path)\n      : Firebase.firestore().doc(path)\n  },\n  storeRef: (state, getters, rootState) => {\n    const path = (state._conf.statePropName)\n      ? `${state._conf.moduleName}/${state._conf.statePropName}`\n      : state._conf.moduleName\n    return getDeepRef(rootState, path)\n  },\n  collectionMode: (state, getters, rootState) => {\n    return (state._conf.firestoreRefType.toLowerCase() === 'collection')\n  },\n  prepareForPatch: (state, getters, rootState, rootGetters) =>\n  (ids = [], doc = {}) => {\n    // get relevant data from the storeRef\n    const collectionMode = getters.collectionMode\n    if (!collectionMode) ids.push('singleDoc')\n    // returns {object} -> {id: data}\n    return ids.reduce((carry, id) => {\n      let patchData = {}\n      // retrieve full object\n      if (!Object.keys(doc).length) {\n        patchData = (collectionMode)\n          ? getters.storeRef[id]\n          : getters.storeRef\n      } else {\n        patchData = doc\n      }\n      patchData = copyObj(patchData)\n      patchData = checkFillables(patchData, state._conf.sync.fillables, state._conf.sync.guard)\n      patchData.updated_at = Firebase.firestore.FieldValue.serverTimestamp()\n      carry[id] = patchData\n      return carry\n    }, {})\n  },\n  prepareForDeletion: (state, getters, rootState, rootGetters) =>\n  (ids = []) => {\n    return ids.reduce((carry, id) => {\n      carry.push(id)\n      return carry\n    }, [])\n  },\n  prepareForInsert: (state, getters, rootState, rootGetters) =>\n  (items = []) => {\n    items = copyObj(items)\n    return items.reduce((carry, item) => {\n      item = checkFillables(item, state._conf.sync.fillables, state._conf.sync.guard)\n      item.created_at = Firebase.firestore.FieldValue.serverTimestamp()\n      item.created_by = rootGetters['user/id']\n      carry.push(item)\n      return carry\n    }, [])\n  }\n}\n\nexport default function (userGetters = {}) {\n  return Object.assign({}, getters, userGetters)\n}\n","\nexport default function errorCheck (config) {\n  let reqProps = ['firestorePath', 'moduleName']\n  reqProps.forEach(prop => {\n    if (!config[prop]) {\n      console.error(`Missing ${prop} from your config!`)\n      return false\n    }\n  })\n  if (/(\\.|\\/)/.test(config.statePropName)) {\n    console.error(`statePropName must only include letters from [a-z]`)\n    return false\n  }\n  if (/\\./.test(config.moduleName)) {\n    console.error(`moduleName must only include letters from [a-z] and forward slashes '/'`)\n    return false\n  }\n  return true\n}\n","import merge from '../utils/deepmerge'\n// store\nimport defaultConfig from './defaultConfig'\nimport initialState from './state'\nimport iniMutations from './mutations'\nimport iniActions from './actions'\nimport iniGetters from './getters'\nimport errorCheck from './errorCheck'\n\n/**\n * A function that returns a vuex module object with seamless 2-way sync for firestore.\n *\n * @param {object} userConfig Takes a config object as per ...\n * @returns {object} the module ready to be included in your vuex store\n */\nexport default function (userConfig) {\n  const conf = merge(defaultConfig, userConfig)\n  if (!errorCheck(conf)) return\n  const userState = conf.state\n  const userMutations = conf.mutations\n  const userActions = conf.actions\n  const userGetters = conf.getters\n  delete conf.state\n  delete conf.mutations\n  delete conf.actions\n  delete conf.getters\n\n  const docContainer = {}\n  if (conf.statePropName) docContainer[conf.statePropName] = {}\n  const state = merge(initialState, userState, docContainer, {_conf: conf})\n  return {\n    namespaced: true,\n    state,\n    mutations: iniMutations(userMutations, merge(initialState, userState)),\n    actions: iniActions(userActions),\n    getters: iniGetters(userGetters)\n  }\n}\n","import Firebase from 'firebase/app'\nimport 'firebase/auth'\nimport { getKeysFromPath } from 'vuex-easy-access'\nimport { isArray } from 'is-what'\nimport iniModule from './module/index'\n\nexport default function createEasyFirestore (userConfig) {\n  return store => {\n    // Get an array of config files\n    if (!isArray(userConfig)) userConfig = [userConfig]\n    // Create a module for each config file\n    userConfig.forEach(config => {\n      const moduleName = getKeysFromPath(config.moduleName)\n      store.registerModule(moduleName, iniModule(config))\n    })\n    store.setDoc = (path, payload) => {\n      return store.dispatch(path + '/setDoc', payload)\n    }\n    store.insert = (path, payload) => {\n      return store.dispatch(path + '/insert', payload)\n    }\n    store.patch = (path, payload) => {\n      return store.dispatch(path + '/patch', payload)\n    }\n    store.patchBatch = (path, payload) => {\n      return store.dispatch(path + '/patchBatch', payload)\n    }\n    store.delete = (path, payload) => {\n      return store.dispatch(path + '/delete', payload)\n    }\n  }\n}\n"],"names":["nanoclone","require","default","toArray","object","result","i","length","push","types","el","type","merger","a","b","keys","Object","concat","forEach","key","Array","isArray","Math","max","merge","config","is","determineType","strategy","name","arguments","reduceRight","element","wrapper","args","apply","l","item","isObject","error","deepmerge","updateStore","doc","store","id","source","change","mutations","state","_sync","syncStack","_conf","firestoreRefType","toLowerCase","_vm","$set","statePropName","newVal","undefined","$delete","userMutations","vuexEasyMutations","defaultMutations","assign","copyObj","obj","newObj","prototype","toString","call","JSON","parse","stringify","len","hasOwnProperty","defaultValues","ms","startTime","Date","now","done","Promise","resolve","reject","interval","setInterval","refresh","retrievePaths","path","reduce","carry","newPath","extra","actions","getters","dispatch","commit","ids","console","log","syncStackItems","prepareForPatch","updates","syncStackIds","prepareForDeletion","deletions","docs","prepareForInsert","inserts","signedIn","debounceTimer","startDebounce","then","collectionMode","dbRef","batch","Firebase","firestore","count","updatesOriginal","map","k","fields","updatesOK","slice","updatesLeft","docRef","flattenToPaths","update","deletionsAmount","deletionsOK","deletionsLeft","delete","insertsAmount","insertsOK","insertsLeft","newRef","set","res","catch","patching","whereFilters","orderBy","identifier","fetched","ref","where","paramsArr","fRequest","fRef","nextFetchRef","limit","fetch","docLimit","retrievedFetchRefs","includes","get","querySnapshot","fetchRef","lastVisible","next","startAfter","auth","currentUser","sync","handleDoc","storeUpdateFn","_doc","syncHookFn","this","onSnapshot","metadata","hasPendingWrites","setDefaultValues","data","serverChange","docChanges","insertHook","patchHook","_id","deleteHook","stopPatchingTimeout","setTimeout","userActions","fillables","guard","rootState","rootGetters","userId","uid","firestorePath","replace","collection","moduleName","getDeepRef","patchData","checkFillables","storeRef","updated_at","FieldValue","serverTimestamp","items","created_at","created_by","userGetters","errorCheck","prop","test","userConfig","conf","defaultConfig","userState","docContainer","initialState","iniMutations","iniActions","iniGetters","createEasyFirestore","getKeysFromPath","registerModule","iniModule","setDoc","payload","insert","patch","patchBatch"],"mappings":"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"}